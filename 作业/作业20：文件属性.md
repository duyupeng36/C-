# 作业20：[[文件属性]]

## 问答题

你认为系统调用 `stat()` 会改变文件 $3$ 个时间戳中的任意之一吗？请解释原因

> [!tip] `stat()` 系统调用不会改变 $3$ 个时间戳中的任意一个。原因如下
> +  **访问时间 (`atime`)**：记录文件的 **最后访问时间**。调用 `stat()` 不会导致这个时间戳更新，*因为只是获取文件的状态，并没有实际读取文件内容*
> + **修改时间 (mtime)**：记录文件内容的 **最后修改时间**。由于 `stat()` *只是获取状态信息，它不会改变文件的内容*，因此 `mtime` 也不会被更新
> + **状态改变时间 (ctime)**：记录文件状态（如权限、链接数等）最后改变的时间。调用 `stat()` 也 *不会改变文件的状态*，因此 `ctime` 也保持不变。
> 

要创建一个新文件，打开一个文件进行读操作，打开一个文件进行写操作，以及删除一个文件，父目录和文件本身分别需要具备何种权限？

| 操作      | 父目录的权限          | 文件的权限 |
| :------ | --------------- | ----- |
| 创建新文件   | Write 和 Execute |       |
| 打开文件用于读 | Execute         | Read  |
| 打开文件用于写 | Execute         | Write |
| 删除文件    | Write 和 Execute |       |

对文件执行重命名操作时，源及目标目录分别需要具备何种权限？若重命名操作的目标文件已存在，该文件需要具备何种权限？

> [!tip] 对文件进行重名操作时，源目录需要 Execute 和 Write 权限，目标目录需要 Write 和 Execute 权限

> [!tip] 目标文件已存在时，目标文件需要具备 Write 权限，以便于覆盖目标文件中的内容

为目录设置 sticky 位(chmod +t)，将如何影响重命名和删除操作

> [!tip] 
> 
> 删除操作：只有文件所有者和特权用户才能删除目录中的文件
> + 即使用户在目录下具备写权限，也只能删除它自己创建的文件
> 
> 重命名操作：用户也只能重命名自己拥有的文件
> 


## 编程题

### 验证下列说法

将文件属主的所有权限“剥夺”后，即使 “本组” 和 “其他” 用户仍有访问权，属主也无法访问文件

![[Pasted image 20241020223739.png]]

在一个 **可读但无可执行权限的目录** 下，可列出其中的文件名，但无论文件本身的权限如何，也不能访问其内容

![[Pasted image 20241020224305.png]]

### 文件权限字符串

Unix/Linux 命令 `ls -l` 可以显示文件的类型和权限。例如

![[Pasted image 20241020162152.png]]

下面我们需要实现将文件权限掩码转换为字符串，采用 `ls` 风格来表示这些掩码

```c title:file_prems.h
#ifndef FILE_PERMS_H
#define FILE_PERMS_H

#include <sys/types.h>

#define FP_SPECIAL 1

char *filePerms(mode_t perm, int flags);

#endif
```

如果在 `filePerms()` 的 `flag` 参数中设置了 `FP_SPECIAL` 标志，那么返回的字符串将包括 `set-user-ID` `set-group-ID`，以及 `sticky` 位的设置信息，其表现形式同样会沿袭 `ls` 的风格

```c title:file_perms.c
#include <stdio.h>

#define __USE_MISC
#include <sys/stat.h>

#include "file_perms.h"


#define STR_SIZE sizeof("rwxrwxrwx")

/** 返回 ls -l 风格的文件权限掩码
 * @param perm: 权限掩码
 * @param flags: 如果指定了 FP_SPECIAL，那么返回的字符串将包括 set-user-ID set-group-ID 和 sticky 置位信息
 * @return 返回静态分配的字符串
 */
char *filePerms(mode_t perm, int flags)
{
    static char permString[STR_SIZE];

    snprintf(permString, STR_SIZE, "%c%c%c%c%c%c%c%c%c",
    // 属主权限
    (perm & S_IRUSR) ? 'r':'-',  // user-read
    (perm & S_IWUSR) ? 'w':'-',  // user-write
    (perm & S_IXUSR) ? 
        ((perm & S_ISUID) && (flags & FP_SPECIAL) ? 's': 'x') :  // set-user-id && user-execute
        ((perm & S_ISUID) && (flags & FP_SPECIAL) ? 'S': '-'),   // set-user-id 
    
    // 属组
    (perm & S_IRGRP) ? 'r': '-',  // group-read
    (perm & S_IWGRP) ? 'w':'-',   // group-write
    (perm & S_IXGRP) ? 
        ((perm & S_ISGID) && (flags & FP_SPECIAL) ? 's': 'x'):  // set-group-id && group-execute
        ((perm & S_ISGID) && (flags & FP_SPECIAL) ? 'S': '-'),  // set-group-id
    
    // 其他
    (perm & S_IROTH) ? 'r': '-',  // other-read
    (perm & S_IWOTH) ? 'w':'-',   //other-write
    (perm & S_IXOTH) ? 
        ((perm & S_ISVTX) && (flags & FP_SPECIAL) ? 't': 'x'):  // sticky && other-execute
        ((perm & S_ISVTX) && (flags & FP_SPECIAL) ? 'T': '-')); // sticky
    
    return permString;
}
```

### 获取并解释文件的 stat 信息

使用 `stat()` 去获取文件的相关信息。若以 `−l` 选项执行命令，程序会改用 `lstat()`，以获取与符号链接的信息

```c title:t_state.c
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/sysmacros.h>  // 获取 major 和 minor

#include "files/file_perms.h"

static void displayStatInfo(struct stat *st)
{
    printf("File type:      ");
    switch (st->st_mode & S_IFMT)
    {
    case S_IFREG:
        printf("regular file\n");
        break;
    case S_IFDIR:
        printf("directory\n");
        break;
    case S_IFCHR:
        printf("character device\n");
        break;
    case S_IFBLK:
        printf("block device\n");
        break;
    case S_IFLNK:
        printf("symbolic soft link\n");
        break;

    case S_IFIFO:
        printf("FIFO or pipe\n");
        break;
    case S_IFSOCK:
        printf("socket\n");
        break;
    
    default:
        printf("unknow file type?\n");
        break;
    }

    printf("Device containing i-node: major=%ld minor=%ld\n", (long) major(st->st_dev), (long)minor(st->st_dev));

    printf("I-node number:            %ld\n", (long) st->st_ino);
    printf("Mode:                     %lo(%s)\n", (unsigned long) st->st_mode, filePerms(st->st_mode, FP_SPECIAL));

    if(st->st_mode & (S_ISUID | S_ISGID | S_ISVTX)) {
        printf("    special bits set: %s%s%s\n", (st->st_mode & S_ISUID)? "set-UID":"", (st->st_mode & S_ISGID)?"set-GID":"", (st->st_mode & S_ISVTX)? "Sticky": "");
    }
    printf("Number of (hard) links: %ld\n", (long) st->st_nlink);
    printf("Ownership:      UID=%ld GID=%ld\n", (long)st->st_uid, (long) st->st_gid);

    if(S_ISCHR(st->st_mode) || S_ISLNK(st->st_mode))
    {
        printf("Device number (st_rdev): major=%ld; minor=%ld\n", (long) major(st->st_rdev), (long) minor(st->st_rdev));
    }
    printf("File size:              %lld bytes\n", (long long) st->st_size);
    printf("Optial IO block size:   %ld bytes\n", (long) st->st_blksize);
    printf("blocks allocated:       %lld\n", (long long)st->st_blocks);
    printf("Last file access:       %s", ctime(&st->st_atime));
    printf("Last file modification: %s", ctime(&st->st_mtime));
    printf("Last status chage:      %s", ctime(&st->st_ctime));
}

int main(int argc, char *argv[])
{

    struct stat st;  // 存储文件信息
    // 是否获取链接信息
    _Bool isLink = argc > 1 && strcmp(argv[1], "-l") == 0;
    // 文件名在 argv 中的索引
    int fname = isLink ? 2 : 1;
    // 检查参数是否正确
    if (fname >= argc || argc > 1 && strcmp(argv[1], "--help") == 0)
    {
        fprintf(stderr, "Usage: %s [-l] pathname\n"
                        "           -l = use lstat() instead of stat()\n",
                argv[0]);
        return -1;
    }

    if (isLink)
    {
	    // 调用 lstat
        if (lstat(argv[fname], &st) == -1)
        {
            perror("lstat");
            return -1;
        }
    }
    else
    {
	    // 调用 stat
        if (stat(argv[fname], &st) == -1)
        {
            perror("stat");
            return -1;
        }
    }
    displayStatInfo(&st);
    return 0;
}
```







