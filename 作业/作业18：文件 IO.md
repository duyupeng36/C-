# 作业18：[[文件 IO：通用 IO 模型]]

## 编程题

### tee 命令

`tee` 命令是从标准输入中读取数据，直至文件结尾，随后将数据写入标准输出和命令行参数所指定的文件。**请使用 I/O 系统调用实现 `tee` 命令**。默认情况下，若已存在与命令行参数指定文件同名的文件，`tee` 命令会将其覆盖。如文件已存在，请实现 `-a` 命令行选项（`tee -a file`）在文件结尾处追加数据。
 
```c

```


### cp 命令

编写一个类似于 `cp` 命令的程序，当使用该程序复制一个包含空洞（连续的空字节）的普通文件时，要求目标文件的空洞与源文件保持一致

```c title:base.h
//
// Created by duyup on 2024/10/11.
//

#ifndef BASE_H
#define BASE_H

// 常用头文件
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

// 文件系统相关头文件
#include <fcntl.h>
#include <sys/stat.h>

// unix 标准头文件
#include <unistd.h>

#endif //BASE_H
```

```c title:errors.h
#ifndef ERRORS_H
#define ERRORS_H

#include "base.h"

#define usageError(argc, target, format, ...)     \
    do                                            \
    {                                             \
        if ((argc) != (target))                   \
        {                                         \
            fprintf(stderr, format, __VA_ARGS__); \
            exit(EXIT_FAILURE);                   \
        }                                         \
    } while (0)

#define catchError(value, target, format, ...)    \
    do                                            \
    {                                             \
        if ((value) == (target))                  \
        {                                         \
            fprintf(stderr, format, __VA_ARGS__); \
            exit(EXIT_FAILURE);                   \
        }                                         \
    } while (0)

#endif // ERRORS_H
```

```c title:copy.c
#include "base.h"
#include "errors.h"

#ifndef BUFFER_SIZE  // 支持 gcc -D
#define BUFFER_SIZE 1024
#endif


int main(int argc, char *argv[]) {

    usageError(argc, 3, "Usage: %s <old-file> <new-file>\n", argv[0]);

    int flags = O_RDONLY;
    int src_fd = open(argv[1], O_RDONLY);
    catchError(src_fd, -1, "Open: %s\n", strerror(errno));

    flags = O_WRONLY | O_CREAT | O_TRUNC;                       // 创建文件用于写入，如果文件存在则截断
    const mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;  // rw-r--r--
    int dst_fd = open( argv[2], flags, mode);
    catchError(dst_fd, -1, "Open: %s\n", strerror(errno));

    // 循环读取
    char buffer[BUFFER_SIZE];
    ssize_t num_read;
    while ((num_read = read(src_fd, buffer, BUFFER_SIZE)) > 0) {
        if(write(dst_fd, buffer, num_read) != num_read) {
            fprintf(stderr, "Write: %s\n", strerror(errno));
            return -1;
        }
    }

    catchError(num_read, -1, "Read: %s\n", strerror(errno));

    // 关闭文件
    catchError(close(src_fd), -1, "Close: %s\n", strerror(errno));
    catchError(close(dst_fd), -1, "Close: %s\n", strerror(errno));
    return 0;
}
```





