# 作业38：线程同步：[[互斥量]] 和 [[条件变量]]

## 编程题

修改 [[互斥量]] 中的 `thread_incr.c` 程序，以便线程起始函数在每次循环中都能输出 `glob` 的当前值以及能对线程做唯一标识的标识符。可将线程的这一唯一标识指定为创建线程的函数 `pthread_create()` 的调用参数。对于这一程序，需要将线程起始函数的参数改为指针，指向包含线程唯一标识和循环次数限制的数据结构。运行该程序，将输出重定向至一文件，查看内核在调度两线程交替执行时 `glob` 的变化情况。

```c title:theads/thread_incr.c

#include <pthread.h>

#include "base.h"

static int glob = 0;

struct args {
    long loops;
    int id;
};

void *incr(void *arg) {
    const struct args args = *(struct args *)arg;
    for(int i = 0; i < args.loops; i++) {
        int loc = glob;
        loc++;
        glob = loc;
        printf("[Thread %d]: glob = %d\n", args.id, glob);
    }
    return nullptr;
}


int main(int argc, char *argv[]) {
    if(argc != 2 || strcmp(argv[1], "--help") == 0) {
        usageErr("%s loops\n", argv[0]);
    }

    long loops = strtol(argv[1], nullptr, 10);
    pthread_t tids[2];
    int err = pthread_create(tids, nullptr, incr, &(struct args){loops, 0});
    if(err != 0) {
        fprintf(stderr, "pthread_create() failed with error %s\n", strerror(err));
        return -1;
    }
    err = pthread_create(tids+1, nullptr, incr, &(struct args){loops, 1});
    if(err != 0) {
        fprintf(stderr, "pthread_create() failed with error %s\n", strerror(err));
        return -1;
    }
    err = pthread_join(tids[0], nullptr);
    if(err != 0) {
        fprintf(stderr, "pthread_join() failed with error %s\n", strerror(err));
        return -1;
    }
    err = pthread_join(tids[1], nullptr);
    if(err != 0) {
        fprintf(stderr, "pthread_join() failed with error %s\n", strerror(err));
        return -1;
    }
    printf("glob = %d\n", glob);
    return 0;
}
```

编译运行该程序，并将输出重定向到 `tfile` 中

```shell
➜  build ./thread_incr 1000000 > tfile
```

---

修改 [[线性表#链表]] 中的代码，使他们称为 **线程安全** 的




