# 作业53：[[C++：多态]]

## 问答题

**C++中有哪几种多态？请详细说明一下**

> [!important] 
> 
> C++ 中的多态分为两种：**静态多态** 和 **动态多态**
> 
> 静态多态：_函数重载_ 和 _模板_
> 
> 动态多态：通过 _虚函数_ 实现。当一个类定义了虚函数，那么该类的对象首地址位置存储了一个指向虚函数表的指针。虚函数表存放的就是虚函数的入口地址。当该类的派生类重写了基类虚函数，那么派生类对象的虚函数表指针指向的虚函数表中的虚函数入口地址就被 **覆盖** 为了派生类的虚函数地址。当使用基类的指针或引用指向派生类对象时，就会发生动态多态。此时，通过基类的指针可以调用派生类的成员函数
> 


---


**在什么情况下析构函数要设置成虚函数？为什么？**

> [!important] 
> 
> 当我们需要通过基类的指针销毁派生类对象时，就需要将析构函数设置为虚析构函数
> 
> 
> 通常情况下，只要一个类定义了虚函数，那么该类的析构函数也需要声明为 `virtual`
> 

---

**什么是纯虚函数？什么是抽象类？抽象类的作用是什么？**

> [!tip] 
> 
> 纯虚函数是一种特殊的虚函数。它通常是在基类不知道如何实现这个虚函数，要让派生类实现时声明的虚函数
> 
> 如果一个类声明了纯虚函数，那么该类称为抽象类。抽象类通常用于控制子类的行为，抽象类的多个子类具有相同的行为，我们就可以认为这些子类都是基类的子类型
> 

---

阅读下列代码写出结果

```cpp
#include<iostream>

using std::endl;
using std::cout;

class Base1
{
public:
    virtual void fun()  // 虚函数
    {   
		cout<<"--Base1--\n";  
	}
};

class Base2
{
public:
    void fun()  // 普通成员函数
    {   
		cout<<"--Base2--\n"; 
	}
};

class Derived
:public Base1
,public Base2
{
public:
    void fun()  // 虚函数：覆盖了 Base1 的虚函数
    {   
        cout<<"--Derived--\n";  
    }
};

int main()
{
    Base1 obj1, *ptr1;  
    Base2 obj2, *ptr2; 
     	
    Derived obj3; 
	

    ptr1 = &obj1;  // Base1 基类的指针指向 Base1 对象         	
    ptr1->fun();   // --Base1--
    
    ptr2 = &obj2; // Base2 基类的指针指向 Base2 对象        	
    ptr2->fun();  // --Base2--  
    
    ptr1 = &obj3; // Base1 基类的指针指向 Derived 对象        	
    ptr1->fun();  // --Derived--，覆盖
    
    ptr2 = &obj3; // Base2 基类的指针指向 Derived 对象         	
    ptr2->fun();  // --Base2--
    
    return 0;	                  
}
```

```cpp
class A
{
public:
 void FuncA()
 {
     printf( "FuncA called\n" );
 }
 virtual void FuncB()
 {
     printf( "FuncB called\n" );
 }
};

class B 
: public A
{
public:
 void FuncA()
 {
     A::FuncA();
     printf( "FuncAB called\n" );
 }
    
 virtual void FuncB()
 {
     printf( "FuncBB called\n" );
 }
};

int main( void )
{
	B	b;
	A	*pa;    // 基类的指针
	pa = &b;    // 基类的指针指向派生类对象
	
	pa->FuncA(); // FuncA 不是虚函数，所以结果为："FuncA called"
	pa->FuncB(); // FuncB 是虚函数，子类覆盖了虚函数 FuncB,所以结果为："FuncBB called"
 
	A *pa2 = new A; // 基类指针指向基类对象
	pa2->FuncA();   // FuncA called
	pa2->FuncB();   // FuncB called
	delete pa2;
	return 0；
}
```

---

```cpp
class Base
{
public:
    Base(int j)
    : i(j) 
    {}
    virtual  ~Base() 
    {} 
    void func1() 
    {
        i *= 10;
        func2();  // 调用虚函数
    }
    
    int getValue()
    {
        return  i;
    }
protected:
    virtual void func2()
    {
        i++;
    }
protected:
    int i;
};

class Child
: public Base
{
public:
    Child(int j)
    : Base(j) 
    {}
    void func1()
    {
        i *= 100;
        func2();
    }
protected:
    void func2()  // 覆盖了基类的虚函数
    {
        i += 2;
    }
};

int main() 
{
    Base * pb = new Child(1);  // 基类指针指向了派生类对象
    pb->func1();
    cout << pb->getValue() << endl;  // 12
    
	delete pb; 
    
	return 0；
} 
```
