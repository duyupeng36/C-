# IO 多路复用


目前为止，我们的程序中使用的 IO 模型都是单个进程 **每次 _只在一个文件描述符_ 上执行 IO 操作**，**每次 IO 系统调用都会 _阻塞_ 直到完成数据传输**。比如，在进程间通信中使用 **FIFO**，当从一个 FIFO 中读取数据时，如果 FIFO 中恰好没有数据，那么通常 `read()` 会阻塞。而如果 FIFO 中没有足够的空间保存待写入的数据时，`write()` 也会阻塞。当在其他类型的文件如 **[[PIPE]]** 和 **[[socket]]** 上执行 I/O 操作时，也会出现相似的行为

> [!tip] 
> 当在某个文件描述符上读取数据时，如果无法该文件描述符上读取数据，那么 `read()` 系统调用就会阻塞
> 
> 当在某个文件描述符上写入数据时，如果文件描述关联文件没有空间写入时，`write()` 系统调用也会阻塞

> [!attention] 磁盘文件是个特例
> 内核采用缓冲区 `cache` 来加速磁盘 I/O 请求。因而一旦请求的数据传输到内核的缓冲区 `cache`，对磁盘的 `write()` 操作将立刻返回，而不用等到将数据实际写入磁盘后才返回（除非在打开文件时指定了 `O_SYNC` 标志 ^[[[文件 IO 缓冲]]]）
> 
> 与之对应的是，`read()` 调用将数据从内核缓冲区 `cache` 移动到用户的缓冲区中，如果请求的数据不在内核缓冲区 `cache`，那么内核就会让进程休眠，同时执行对磁盘的读操作
> 

对于许多应用来说，传统的 **阻塞 IO 模型** 已经足够了，但这不代表所有的应用都能得到满足。特别的，有些应用需要处理以下某项任务，或者两者都需要兼顾

> [!tip] 
> 
> 如果可能的话，**以 _非阻塞_ 的方式检查文件描述符上是否可进行 I/O 操作**
> 
> **同时检查多个文件描述符**，看它们中的任何一个是否可以执行 I/O 操作
> 

目前，我们可以使用 **非阻塞 IO** 技术检查文件描述符上是否可以执行 IO 操作。我们马上将介绍 **IO 多路复用**，用于同时检查多个文件描述符。后续，我们还会介绍 **多进程** 或 **多线程** 技术

## IO 模型

 [[文件 IO：通用 IO 模型]] 中我们介绍了 **同步阻塞 IO** 模型；[[深入文件 IO#非阻塞 IO]] 和 [[FIFO#非阻塞 IO]] 我们介绍了 **同步非阻塞 IO** 模型。下面我们加强这两个概念，并介绍另外一种 IO 模型

> [!tip] IO 操作的两个阶段：**数据准备** 和 **获取数据**
> 
> **数据准备阶段**：将数据从设备 _搬运_ 到内核空间中的缓冲区
> 
> **进程获取数据阶段**：从内核缓冲区 _复制_ 到用户空间的缓冲区
> 

### 同步 IO

> [!tip] 同步：所谓的同步就是 **等待结果的返回**
> 
> 通俗来说，**不达目的誓不罢休**，如果是函数调用，函数必须返回的最终结果。等待函数返回这段时间称为 **阻塞**
> 

#### 阻塞 IO 

**阻塞 IO** 是指在执行 IO 操作时，**调用线程会被阻塞**，**等待 _IO 操作完成后_ 才能继续执行后续代码**。此时，**线程处于等待状态**，无法执行其他任务

> [!tip]
> 当一个阻塞 IO 操作（如读取文件或从网络接收数据）被发起时，调用线程会暂停，直到数据读取或写入操作完成。操作完成后，线程才会继续执行后续代码
> 

![[Pasted image 20241030205651.png]]


> [!tip] 阻塞 IO 特点
> 
> 进程等待（阻塞），直到读写完成。（全程等待)
> 

为了避免进程/线程被 IO 操作阻塞，可以创建一个新的进程/线程来执行 IO 操作。父进程/线程就可以处理其他任务，而子进程/线程阻塞等待 IO 操作完成

> [!attention] 进程和线程处理阻塞 IO 的局限性
> 
> 使用进程会 **带来额外的开销**，创建进程和维护进程对系统来说都有开销。而且子进程需要通过 IPC 对象来通知父进程 IO 操作的状态，使得 **编程变得复杂**
> 
> 使用线程可以减少占用的资源。但是线程也需要通信，使得 **编程工作变得复杂**
> 

#### 非阻塞 IO

**非阻塞 I/O** 可以让我们 **周期性** 地检查（“轮询”）某个文件描述符上是否可执行 I/O 操作

> [!tip]
> 比如，我们可以让一个输入文件描述符成为非阻塞式的，然后周期性地执行非阻塞式的读操作

如果我们需要 **同时检查多个文件描述符**，那么就需要将它们 **都设为非阻塞**，然后依次对它们 **轮询**

> [!tip]
> 在一个紧凑的循环中 **做轮询就是在浪费 CPU**

下图描述了 **非阻塞 IO** 的轮询过程

![[Pasted image 20241030205845.png]]

> [!attention] 非阻塞 IO 的局限性
> 
> 使用非阻塞 IO 可以 **轮询** 检查多个文件描述是否可以执行 IO 操作。如果 **轮询的频率较低**，应用程序 **响应 IO 时间可能会延迟**。如果 **轮向频率较高**，可能 **带来 CPU 的浪费**
> 

### 备选 IO 模型

由于非阻塞 IO 和多进程/多线程的局限性，其他的备选的 IO 模型往往更可取

> [!tip] 
> 
> + **IO 多路复用**：允许我们 **同时检查多个文件描述符**，看其中任意一个是否可执行 I/O 操作。有两个功能几乎相同的 **系统调用** 来执行 I/O 多路复用操作：`select()` 和 `poll()`
>  + **epoll** API 是 Linux 专有的特性。与 IO 多路复用一样，可以同时检查多个文件描述。当同时检查的文件描述符非常多时，epoll 可以提供更好的性能
> + **信号驱动 IO**：当有输入或者数据可以写到指定的文件描述符上时，内核向请求数据的进程发送一个信号。进程可以处理其他的任务，当 IO 操作可执行时通过接收信号来获得通知。当同时检查大量的文件描述符时，信号驱动 IO 相比 `select()` 和 `poll()` 有显著的性能提升
> + **异步 IO**：
>
> 下面我们将马上介绍 IO 多路复用。其他 IO 模型，会陆续被介绍 [[信号驱动 IO]] [[epoll]]
> 

这些备选都是用来实现同一个目标技术：**同时检查多个文件描述符**，看看它们是否准备好了执行 IO 操作。准确说，是看 IO 系统调用是否可以非阻塞地执行

> [!tip] 
> 
> 文件描述符就绪状态的转化是通过一些 I/O 事件来触发的
> + 输入数据以到达
> + 套接字连接建立完成
> + 之前满载的套接字发送缓冲区中的数据传送到了对端
> 

同时检查多个文件描述符在网络服务程序中非常有用，或者那些必须同时检查终端以及管道或套接字输入的应用程序

> [!attention] 
> 
> 这些技术都 **不会执行实际的 I/O 操作**。它们只是 **告诉我们某个文件描述符已经处于就绪状态了**。这时 **需要调用其他的系统调用来完成实际的 I/O 操作**。
> 

### 水平触发和边缘触发

在学习 IO 多路复用之前，先了解两种 文件描述符准备就绪的 **通知模式**：**水平触发** 和 **边缘触发**

> [!tip] 水平触发：如果文件描述符上 **可以非阻塞地执行 I/O 系统调用**，此时认为它已经就绪
> 
> 允许我们 **在 _任意时刻_ 检查文件描述符的就绪状态**。这样，我们就可以在文件描述符就绪时，可以对其 **执行一些 IO 操作**，然后 **重复检查文件描述符**，看看是否仍然处于就绪状态
> 
> 换句话说，由于水平触发模式允许我们在任意时刻重复检查 I/O 状态，**没有必要每次当文件描述符就绪后需要尽可能多地执行 I/O**（也就是尽可能多地读取字节，亦或是根本不去执行任何 I/O）
> 

> [!tip] 边缘触发：如果文件描述符自上次状态检查以来 **有了新的 I/O 活动**，此时需要触发通知
> 
> **只有当 I/O 事件发生时我们才会收到通知**，并且在另一个 IO 事件到来前，我们不会收到任何新的通知
> 
> 

> [!attention] 边缘触发通知的程序的设计规范
> 
>  然而，当文件描述符 **收到 IO 事件通知** 时，通常我们是 **不知道要处理多少 IO**(即可以读取多少字节)。因此，采用边缘触发通知的程序应该按照如下设计
> 
> 文件描述符接 **收到 IO 事件通知** 后，程序在某个时刻 **应该尽可能多的执行 IO**。如果程序没有这么做，那么就失去执行 IO 的机会。因为在产生另一个 I/O 事件到来前，程序都不会再接收到通知了，因此也就不知道此时应该执行 I/O 操作。从而导致数据丢失或程序出现阻塞
>  + 当确定了文件描述符就绪时，此时可能并不适合马上执行所有的 IO 操作。原因在于，如果我们仅对一个文件描述符执行大量的 I/O 操作，可能会让其他文件描述符处于饥饿状态
> 
> **每个被检查的 _文件描述符_ 通常都应该置为 _非阻塞模式_**，在得到 I/O 事件通知后重复执行I/O 操作，直到相应的系统调用（比如 read()，write()）以错误码 `EAGAIN` 或`EWOULDBLOCK` 的形式失败
> + 如果程序采用循环来对文件描述符执行尽可能多的 I/O，而文件描述符又被置为可阻塞的，那么最终当没有更多的 I/O 可执行时，I/O 系统调用就会阻塞
> 

## IO 多路复用

**IO 多路复用** 允许我们同时检查多个文件描述符，看其中任意一个是否可执行 I/O 操作。有两个功能几乎相同的 **系统调用** 来执行 I/O 多路复用操作：`select()` 和 `poll()`

> [!tip]
> 
> 同时监控多个IO，称为多路IO，哪怕只有一路准备好了，就不需要等了就可以开始处理这一路的数据。这种方式提高了同时处理 IO 的能力
> 

> [!tip] 
> `select()` 和 `poll()` 可以检查普通文件、[[PIPE]] 、[[FIFO]]、[[socket]] 等其他类型文件的文件描述符

这两个系统调用都允许进程 **要么一直等待文件描述符成为就绪态**，要么在调用中 **指定一个超时时间**。

![[Pasted image 20241030230515.png]]

> [!tip] 
> 
> 应用程序进程通过系统调用 `select/poll` 将需要监控的文件描述符注册到内核，让内核监控这些文件描述符。当文件描述符就绪时，`select/poll` 返回。然后，对已就绪的文件描述符执行 IO 操作
> 

### select




### poll










