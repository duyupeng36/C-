# 字符串和字节序列

我们在 [[Python：基础语法#字符串类型]] 中介绍过字符串的基本概念和基本操作。下面我们深入理解字符串。谈及字符串，我们不得不回顾 [[数据存储#存储文本]] 中的内容了。

由于计算机只认识 $0$ 和 $1$ 组成的位模式。为了让计算机能够处理某个地区字符数据，就需要将该地区的基本字符与一个位模式相对应

> [!tip] 
> 
> 将位模式与某个地区基本字符关联的过程称为 **编码**。当将所有的基本字符都与一个位模式想对应之后，就会形成一张 **编码表**，也成为 **字符集**
> 

要完整的编码某个地区的基本字符需要的位模式长度 $n$ 取决于基本字符的个数

| 位模式长度 | 编码个数  |
| :---- | :---- |
| $1$   | $2$   |
| $2$   | $4$   |
| $3$   | $8$   |
| $...$ | $...$ |
| $n$   | $2^n$ |

> [!tip] 
> 
> 假设某个地区的基本字符有 $N$ 个，则需要长度为 $n = \lceil \log_2(N)  \rceil$ 位模式才能完全编码 
> 

## ASCII 字符集

ASCII 字符集是美国信息交换标准码。使用长度为 $7$ 的位模式表示了 $2^{7}=128$ 个字符。其中包括 $33$ 个控制字符和 $95$ 个可打印字符

![[Pasted image 20240621145612.png|900]]
![[Pasted image 20240621145525.png|900]]

对于 ASCII 字符集，其中有几个字符的编码需要我们记忆

|         字符         |    位模式     | 十进制  |  十六进制   |
| :----------------: | :--------: | :--: | :-----: |
| `NULL` 字符 (`'\0'`) | `000 0000` | `0`  | `0x00 ` |
| `SPACE` 字符 (`' '`) | `010 0000` | `32` | `0x20 ` |
|  `HT` 字符 (`'\t'`)  | `000 1001` | `9`  | `0x09 ` |
|  `CR` 字符 (`'\r'`)  | `000 1101` | `13` | `0x0d ` |
|  `LF` 字符 (`'\n'`)  | `000 1010` | `10` | `0x0a ` |
|  `VT` 字符 (`'\v'`)  | `000 1011` | `11` | `0x0b ` |
|  `FF` 字符 (`'\f'`)  | `000 1100` | `12` | `0x0c ` |
|      字符 `'0'`      | `011 0000` | `48` | `0x30 ` |
|      字符 `'1'`      | `011 0001` | `49` | `0x31 ` |
|      字符 `'A'`      | `100 0001` | `65` | `0x41 ` |
|      字符 `'a'`      | `110 0001` | `97` | `0x61`  |

## Unicode 字符集

随着计算机在全世界的普及和互联网的发展，让计算机能处理特定区域的文本迫在眉睫。每个地区都设计了能够处理当地文本的字符集。例如，中国的 `GB/T 2312, GBK`，日本的 `Shift JIS` 等编码

由于不同地区使用的字符集编码方式不同，在不同国家间就会经常出现不兼容的情况。很多传统的编码方式都有共同的问题，即 **允许电脑处理双语环境**（通常使用拉丁字母以及其本地语言），但却 **无法同时支持多语言环境**（指可同时处理多种语言混合的情况）。

为此，硬件和软件制造商联合起来共同设计了一种名为 `Unicode` 的编码，称为 **统一码**。它 **为每一个字符而非字形定义唯一的代码（即一个整数）**

> [!tip] 字符的视觉演绎留给其他软件处理
> 
> 统一码以一种抽象的方式（即数字）来处理字符，并将字体大小、外观形状、字体形态、文体等工作留给其他软件来处理
> 

Unicode 编码系统可分为 **编码方式** 和 **实现方式** 两个层次

#### 编码方式

目前实际应用的统一码版本对应于 **UCS-2**，使用 $16$ 位的编码空间。也就是每个字符占用 $2$ 个字节。这样理论上一共最多可以表示 $2^{16}$（即 $65536$）个字符。基本满足各种语言的使用

最新（但未实际广泛使用）的统一码版本定义了 $16$ 个辅助平面，两者合起来至少需要占据 $21$ 位的编码空间，比 $3$ 字节略少。但事实上辅助平面字符仍然占用 $4$ 字节编码空间，与 **UCS-4** 保持一致

#### 实现方式 UTF-8

Unicode 编码方式确定了字符的二进制表示。但是，需要存储字符串时，如何存储呢？首先就是直接存储这些编号的位模式。如下实例

```
"hello, 世界!"
字符 编号(hex)  位模式
h    68        01101000
e    65        01100101
l    6c        01101100
l    6c        01101100
o    6f        01101111
,    2c        00101100
     20        00100000
世   4E16      01001110 00010110
界   754C      01110101 01001100
!    21        00100001

011010000110010101101100011011000110111100101100001000000100111000010110011101010100110000100001
```

> [!question] 
> 
> 直接存储字符的位模式有一个棘手的问题！**如何区分字符边界？**
> 

首先想到的就是按照编码最长的位模式存储，不足的在左边使用 $0$ 补齐位模式。比如，按照 UCS-2 标准编码的字符，需要如下方式存储 `"hello, 世界!"` 

```
00000000 01101000
00000000 01100101
00000000 01101100
00000000 01101100
00000000 01101111
00000000 00101100
00000000 00100000
01001110 00010110
01110101 01001100
00000000 00100001
```

> [!question] 
> 
> 好多字节存储的都是 $0$，这些 $0$ 都是无效为，比较浪费内存
> 

---

一个字符的 Unicode 代码是确定。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及 **出于 _节省空间_ 的目的**，对 Unicode 编码的实现方式有所不同。**Unicode 的实现方式称为 Unicode 转换格式（Unicode Transformation Format，简称为`UTF`）**。最常用的 `UTF-8(8-bit Unicode Transformation Format)` 编码

> [!tip] UTF-8 转换格式采用了如下转换模板
> ```
> U+0000 .... U+007F(0 ~ 127)      0xxxxxxx
> U+0080 .... U+07FF(128~2047)     110xxxxx 10xxxxxx
> U+0800 .... U+FFFF(2048~65535)   1110xxxx 10xxxxxx 10xxxxxx
> ```

UTF-8 使用 $1 \sim 6$ 个字节为每个字符编码（尽管如此，2003年11月 UTF-8 被 RFC 3629 重新规范，只能使用原来 Unicode 定义的区域，U+0000 到 U+10FFFF，也就是说 **最多四个字节**）。比如

```
"hello, 世界!"
字符 编号(hex)  位模式
h    68        01101000
e    65        01100101
l    6c        01101100
l    6c        01101100
o    6f        01101111
,    2c        00101100
     20        00100000
世   4E16      01001110 00010110
界   754C      01110101 01001100
!    21        00100001

01101000 01100101 01101100 01101100 01101111 00101100 00100000 11100100 10111000 10010110 11100111 10010101 10001100 00100001
```

> [!NOTE] UTF-8 编码 UCS-4 的编码范围为 `U+0000` 到 `U+10FFFF`

下图展示了 Unicode 与 UTF-8 的转换过程

![[assets/attachments/Pasted image 20240621150535.png|900]]

## 字符串

Python 中字符串是一个不可变序列。默认情况下存储的是每个字符的 UTF-8 编码

例如字符串 `"hello, 世界!"`，下面列出了每个字符的 Unicode 编码和 UTF-8 编码

```python
"hello, 世界!"
字符 编号(hex)  位模式              UTF-8
h    68        01101000           0|1101000
e    65        01100101           0|1100101
l    6c        01101100           0|1101100
l    6c        01101100           0|1101100
o    6f        01101111           0|1101111
,    2c        00101100           0|0101100
     20        00100000           0|0100000
世   4E16      01001110 00010110  1110|0100 10|111000 10|010110  
界   754C      01110101 01001100  1110|0111 10|010101 10|001100
!    21        00100001           0|0100001
```

所以在内存中，字符串 `"hello, 世界!"` 存储为 `01101000(h) 01100101(e) 01101100(l) 01101100(l) 01101111(o) 00101100(,) 00100000( ) 11100100 10111000 10010110(世) 11100111 10010101 10001100(界) 00100001(!)`

### 内置函数：ord() 和 chr()

内置函数 `ord()` 可以获取长度为 $1$ 的字符串的编码值(整数)

```python
>>> ord('a')
97
>>> ord('汉')
27721
```

内置函数 `chr()`可以将一个整数转换为对应编码，且长度为 $1$ 的字符串

```python
>>> chr(97)
'a'
>>> chr(27721)
'汉'
```

> [!important] 
> 
> Python 不能像 C 语言那样将字符当中整数使用。如果需类似的语义，请使用 `ord()` 将字符转换为其编码
> 

### 字符串方法



