# 序列化

程序产生的数据在内存被组织为各种各样的数据结构。内存中的数据是临时的易变的，为了持久化存储内存中的数据，应该将内存中的数据保存在磁盘上。

然而，在 [[文件系统]] 和 [[文件系统的实现]] 中介绍过，磁盘上存储的数据逻辑上是顺序存储的，不存在像内存中那样的数据结构。因此，将内存中的数据保存为文件存在一个天然的问题：**如何将一个复杂的数据结构存储在文件中**？当将复杂数据结构存储在文件中后，又应该 **如何将磁盘中的数据还原为内存中的数据结构？**

> [!tip] 
> 
> 为了让内存中的复杂数据结构存储在文件中，需要设计一套 **协议** 将复杂数据结构的信息和数据保存在文件中。当从文件中读取时，可以根据数据结构的信息在内存中还原已经存储下来的数据
> 

由于文件在逻辑上是字节的序列，将内存中的复杂数据结构保存在文件中的过程称为 **序列化(serialization)**。将文件中的数据还原为内存中的复杂数据结构的过程称为 **反序列化(deserialization)**

> [!tip] 序列化
> 
> 将内存中复杂的数据结构存储下来，把它变成一个个字节。将内存中的数据结构按照某种协议存储到文件中。为了方便反序列化，需要保存的数据包括
> + 复杂数据结构的 **类型**
> + 复杂数据结构中的 **数据**
> + 数据间的 **间隔**
> 


> [!tip] 反序列化
> 
> 根据文件中已经存储的信息，在内存中还原复杂的数据结构
> 

序列化后的数据可以保存到文件进行持久化；也可以通过网络传输。当我们有一个序列化的文件中或者从网络接收到的字节序列，可以进行反序列化，从而在内存中还原数据结构

> [!tip] 
> 
> Python 提供了专供 Python 自己使用的序列化协议 `pickle`
> 

## pickle 协议

模块 `pickle` 实现了对一个 Python 对象结构的二进制序列化和反序列化。 `"pickling"` 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 `"unpickling"` 是相反的操作，会将（来自一个 `binary file` 或者 `bytes-like object `的）字节流转化回一个对象层次结构。 `pickling` 也被称为 **“序列化”**, **“编组”**  或者 **“平面化”**

`pickle` 模块中的序列化和反序列化函数如下表所示

| 函数      | 说明                   |
| :------ | :------------------- |
| `dumps` | 对象序列化为 `bytes` 对象    |
| `dump`  | 对象序列化并写入文件           |
| `loads` | 从 `bytes` 对象中反序列化出对象 |
| `load`  | 从文件中读取数据，并反序列化出对象    |

```python
import pickle

filename = "data.pkl"

i = 99
c = 'c'

l = list(range(1,4))

d = {"a": 1, "b": "abc", "c": [1,2,3,4]}

# 序列化
with open(filename, "wb") as f:
    pickle.dump(i, f)  # int类型 数据 边界
    pickle.dump(c, f)  # str类型 'c' 边界
    pickle.dump(l, f)  # list类型 [类型-1-边界, 类型-2-边界,类型-3-边界....] 边界
    pickle.dump(d, f)  # dict类型 {类型-key-边界: 类型-value-边界, ....} 边界

# 反序列化
with open(filename, "rb") as f:
    for i in range(4):
        print(pickle.load(f))
```





## JSON 协议



## MessagePack 协议


