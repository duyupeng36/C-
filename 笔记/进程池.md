# 进程池

## 设计背景

如果要实现一个 **网络文件传输存储（即网盘）** 应用程序，需要涉及 **文件**、**进程**、**线程** 和 **网络** 等等。但是之前所学习的内容都是零散的知识点，我们需要综合这些所有的知识点，然后从一个更高的层面，也就是 **从整体设计的角度来思考应用程序的架构**，这样才能构建一个高质量的网盘项目。

一个良好的架构需要满足许多侧面的要求，其中最基本的要求是 **可维护性** 和 **性能**：

> [!tip] 可维护性：指应用程序 **对开发者应该足够友好**，**开发** 和 **维护** 的程序员可以很 **快速的就能理解程序架构** 并进行后续开发
> 
> 
> 

为了提供可维护性，**网盘的各个部分的功能应当彼此分离**。在这里，我们将网盘设计成一个 **多进程的应用**：存在一个 **主进程** 和 **多个子进程**

> [!attention] 
> 
> **主进程** 负责处理启动程序、管理子进程和处理客户端请求
> 
> **子进程** 也叫工作进程，负责真正的传输文件
> 

> [!tip] 性能：应用程序应当 **充分利用操作系统资源**，并且 **减少不必要资源消耗**
> 

在多进程程序中，一种 **非常浪费资源的操作就是创建进程**。在网盘项目中，如果每有一个传输文件的请求，程序就要去创建一个进程，那么大量的时间都消耗在进程的创建和销毁当中

> [!tip] 一种优化的思路就是 **“池化”**
> 
> 在应用程序启动的时候就创建多个子进程，这些子进程不会在执行过程中动态的创建和回收，它们一直存在直到应用程序终止
> + 如果没有任务时，子进程睡眠
> + 每当有传输文件的请求到来时，会唤醒某个子进程来完成任务
> + 文件传输完成之后，子进程会重新陷入睡眠
> 

## 网盘整体结构：进程池版本

下图展示了进程池版本的网盘结构

![[Pasted image 20241207210443.png]]

首先，就需要布局好代码

```shell
~/processPoll$ tree 
.
├── client
│   ├── main.c
│   ├── Makefile
│   └── README.md
└── server
    ├── main.c
    ├── Makefile
    ├── README.md
    ├── server.h
    └── worker.c
```

`server` 或 `client` 中的 `Makefile` 的内容如下

```shell
# 可执行程序名
EXECNAME := server # client  
# 源文件名
SRCS := $(wildcard *.c)
# 目标文件名
OBJECTS := $(patsubst %.c,%.o, $(SRCS))
# gcc 编译器
CC := $(shell which gcc)
# gcc 编译选项
CFLAGS := -Wall -g -Og

# 第一个目标：可执行文件
$(EXECNAME): $(OBJECTS)
	$(CC) $^ -o $@

%.o:%.c
	$(CC) $(CFLAGS) -c $^ -o $@

.PHONY: clean rebuild
clean:
	$(RM) $(OBJECTS)

rebuild: clean $(EXECNAME)
```

然后，设计数据结构。进程池主要围绕两种结构：**工作进程** 和 **进程状态**

```c title:server/server.h
/** worker_state_t: define worker states
 */
typedef enum {
    WORKER_STATE_IDLE,  // Worker is idle and can accept new tasks
    WORKER_STATE_BUSY   // Worker is busy and cannot accept new tasks
} worker_state_t;

/** worker_t: define worker
 */
typedef struct {
    pid_t pid;
    worker_state_t state;
} worker_t;
```

最后，设计相关的函数，对数据结构进行增删查改

> [!tip] 函数设计
> 
> 项目组需要开会讨论确定 **函数名**、**函数参数类型** 和 **返回值类型**。一个函数可能被多个模块使用，不能随便改动。
> 
> 在进行函数设计时，涉及两类人员：**实现者** 和 **使用者**
> + 实现者：决定主要参数个数和类型
> + 使用者：提供建议和补充
> 

## 进程池实现

### 创建工作进程 make_worker()

应用程序启动时，创建一批工作进程，并等待任务到来。创建工作进程的接口 `make_workers()`

```c title:server/worker.h
/**
 * @brief Create process pool
 * 
 * @param workers An array that stores sub-process information.
 * @param maxlength Maximum length of workers
 * @return on success return 0, otherwise return -1
 */
int createProcessPoll(worker_t *workers, size_t maxlength);
```

实现 `make_worker()` 需要完成两个任务：**调用 fork() 创建子进程** 和 修改 `workers` 数组

```c title:server/worker.c
#include <unistd.h>
#include "worker.h"

int createProcessPoll(worker_t *workers, size_t maxlength) {
    for(int i = 0; i < maxlength; i++) {
        pid_t pid;
        switch (pid = fork())
        {
        case -1: // fork 失败
            return -1;
        case 0: // 子进程
            /* 让子进程陷入循环，不要脱离这里，否则子进程也会调用 fork() */
            while (true)
            {
                sleep(1);
            } 
            break;
        default:  // 父进程
            workers[i].pid = pid;
            workers[i].state = WORKER_STATE_IDLE;
            break;
        }
    }
    return 0;
}
```

### 父进程处理网络连接

在创建完所有的子进程之后，父进程的下一个工作目标是准备接受客户端的TCP连接，这个工作和之前网络编程时的工作内容差不多，按照 `socket`  `bind` 和 `listen` 的顺序执行系统调用即可。我们将它们封装到一个函数中 `listenTCPSocket()` 中，该函数的原型定义如下

```c title:server/tcp.h
#ifndef TCP_H
#define TCP_H

#include <sys/types.h>
#include <sys/socket.h>
#define __USE_XOPEN2K
#include <netdb.h>

#define PROTOCOL_IP 0x01
#define PROTOCOL_IPV6 0x02

/**
 * @brief Return listening socket
 * 
 * @param hostname this is ip address or domain name
 * @param service  this is port number or service name
 * @param protocol 0x01 for IPv4, 0x02 for IPv6
 * @return on success, return listening socket file descriptor; on error, return -1
 */
int listenTCPSocket(const char *hostname, const char *service, int protocol);
#endif

```

参数 `flags` 通常取 $0$ 或者 `O_NONBLOCK`。下面是 `listenTCPSocket()` 的实现

```c title:server/tcp.c
#include <string.h>

#include "tcp.h"

int listenTCPSocket(const char *hostname, const char *service, int protocol) {
    struct addrinfo hints, *result = NULL;
    memset(&hints, 0, sizeof(struct addrinfo));    

    switch (protocol)
    {
    case PROTOCOL_IP:
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_family = AF_INET;
        hints.ai_flags = AI_PASSIVE;
        break;
    case PROTOCOL_IPV6:
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_family = AF_INET6;
        hints.ai_flags = AI_PASSIVE;
        break;
    default:
        return -1;
    }
    // 获取地址信息
    if(getaddrinfo(hostname, service, &hints, &result) == -1) {
        return -1;
    }
    // 创建 SOCKET
    int sockfd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if(sockfd == -1) {
        freeaddrinfo(result);
        return -1;
    }
    // 绑定地址
    if(bind(sockfd, result->ai_addr, result->ai_addrlen) == -1) {
        freeaddrinfo(result);
        close(sockfd);
        return -1;
    }
    // 将 SOCKET 转换为监听套接字
    if(listen(sockfd, SOMAXCONN) == -1) {
        freeaddrinfo(result);
        close(sockfd);
        return -1;
    }
    // 释放 addrinfo 链表
    freeaddrinfo(result);
    return sockfd;
}
```

如果需要使用 epoll 边缘触发监控 LISTEN SOCKET 和 CONN SOCKET，就需要将文件描述符设置为非阻塞的

```c title:server/tcp.h
/**
 * @brief Set fd to non-blocking
 * 
 * @param fd file descriptor
 * @return on success return 0, otherwise return -1
 */
int setNonBlock(int fd);
```

```c title:server/tcp.c
int setNonBlock(int fd) {
    int flags = fcntl(fd, F_GETFL);
    if(flags == -1) {
        return -1;
    }
    flags |= O_NONBLOCK;
    if(fcntl(fd, F_SETFL, flags) == -1) {
        return -1;
    }
    return 0;
}
```

下面封装了将文件描述符添加到 epoll 实例中的操作

```c title:server/epoll.h
#ifndef EPOLL_H
#define EPOLL_H
#include <sys/types.h>
#include <sys/epoll.h>

/**
 * @brief Add fd to the epoll instance to listen for events events
 * 
 * @param epfd File descriptor for the epoll instance
 * @param fd  The file descriptor to add
 * @param events Events to listen fo
 * @return on success return 0, otherwise return -1
 */
int epoll_add(int epfd, int fd, int events);

/**
 * @brief delete fd from the epoll instance
 * 
 * @param epfd File descriptor for the epoll instance
 * @param fd The file descriptor to delete
 * @return on success return 0, otherwise return -1
 */
int epoll_del(int epfd, int fd);
#endif
```

```c title:server/epoll.c
#include <stddef.h>
#include "epoll.h"

int epoll_add(int epfd, int fd, int events) {
    struct epoll_event ev;
    ev.events = events;
    ev.data.fd = fd;
    if(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) == -1) {
        return -1;
    }
    return 0;
}

int epoll_del(int epfd, int fd) {
    if(epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL) == -1) {
        return -1;
    }
    return 0;
}
```

每当有客户端连接时，就 **接收客户端连接**，产生一个全新的用于通信的 **对等 SOCKET**

```c title:server/main.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#include <unistd.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/socket.h>

#include "server.h"

#define WORKER_NUMBER 5
#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"

int main(int argc, char *argv[]) {
    if(argc > 1 && strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <hostname> <service> <worker number>\n", argv[0]);
        return 1;
    }
    char * hostname = argc > 1 ? argv[1] : HOSTNAME;
    char * service = argc > 2 ? argv[2] : SERVICE;
    int worker_number = argc > 3 ? atoi(argv[3]) : WORKER_NUMBER;

    // 创建工作线程
    worker_t workers[worker_number];
    if(make_workers(workers, worker_number) == -1) {
        fprintf(stderr, "Failed to create %d workers\n", worker_number);
        return 1; 
    }

    // 监听 IP:PORT
    int sockfd = listenTCP(hostname, service, O_NONBLOCK);
    if(sockfd == -1) {
        fprintf(stderr, "Failed to listen on %s:%s\n", hostname, service);
        return 1;
    }

    // 创建 epoll 实例
    int epfd = epoll_create(1024);
    if(epfd == -1) {
        fprintf(stderr, "Failed to create epoll instance\n");
        return 1;
    }

    if(epoll_add(epfd, sockfd, EPOLLIN|EPOLLET) == -1) {
        fprintf(stderr, "Failed to add sockfd to epoll\n");
        return 1;
    }

    // 开启事件循环
    int max_length = 1024;
    struct epoll_event *events = malloc(sizeof(struct epoll_event) * max_length);
    while (true)
    {
        int readyNumber = epoll_wait(epfd, events, max_length, -1);
        if(readyNumber == -1) {
            fprintf(stderr, "Failed to wait for events\n");
            return 1;
        }
        for(int i = 0; i < readyNumber; i++) {
            if(events[i].data.fd == sockfd) {
                // 有客户端连接
                int connfd = accept(sockfd, NULL, NULL);
                // TODO: 处理连接
            }
        }
    }
    
    return 0;
}
```

现在，我们遇见了一个问题。在 [[虚拟内存]] 我们介绍了进程之间的虚拟地址空间是隔离的。由于进程池中的进程是在建立连接之前创建的。我们遇见的第一个问题就是 **如何将父进程中的打开文件描述传递给进程池中的进程？**

### 父子进程之间共享打开文件描述

由于连接 SOCKET 需要递交给子进程使用。然而，**父进程和子进程之间的地址空间是隔离的**。又由于 **提前创建子进程**，连接 SOCKET 不在父子进程之间共享。我们需要某种方式 **将连接 SOCKET 发送给子进程**

![[Pasted image 20241207234647.png]]

> [!tip] 父子进程之间传递 **打开文件描述**
> 
> 这里，我们需要使用 [[SOCKET：高级主题#sendmsg() 和 recvmsg()]] 系统调用，可以将一个进程的打开文件描述发送给另一个进程
> 

基于 **本地套接字** 的 **全双工** 管道，可以完成上述说明的在父子进程之间传递打开文件描述。系统调用 `socketpair()` 创建一对已连接的 SOCKET 对象

```c
#include <sys/socket.h>

int socketpair(int domain, int type, int protocol, int sv[2]);
```

> [!tip] 参数 `domain`：指定通信域
> 
> 该参数通常选择 `AF_UNIX` 或者 `AF_LOCAL`，代表本地计算机通信域。通常是同一个计算机内的多个进程之间传递消息
> 
> 更多通信域参考： [[SOCKET 概览#创建 SOCKET]]
> 

> [!tip] 参数 `type`：SOCKET 类型
> 
> 通常是 `SOCK_STREAM` 或者 `SOCK_DGRAM`
> 
> 更多 SOCKET 类型参考： [[SOCKET 概览#创建 SOCKET]]
> 

> [!tip] 参数 `protocol`：额外协议编号
> 
> 通常取 $0$
> 

> [!tip] 参数 `sv`：长度为 $2$ 数组，用来存储管道两端的文件描述符
> 
> 与 [[PIPE]] 不同的是，`sv[0]` 和 `sv[1]` 没有任何区别
> + 如果从 `sv[0]` 写入，那么就必须从 `sv[1]` 读取
> + 如果从 `sv[0]` 读取，那么就必须从 `sv[1]` 写入
> 

一般 `socketpair()` 之后会调用 `fork()`，从而实现现父子进程之间的通信。下面将传递文件描述符封装为下面两个函数 `sendfd()` 和 `recvfd()`

```c title:server/unix.h
#ifndef UNIX_H
#define UNIX_H
#include <sys/types.h>
#include <sys/socket.h>

/**
 * @brief Pass open file descriptions via UNIX domain sockets
 * 
 * @param sockfd UNIX domain socket
 * @param fd The file descriptor to be passed
 * @return on success, return 0; on error, return -1 
 */
int sendfd(int sockfd, int fd);

/**
 * @brief Receive file descriptions via UNIX domain sockets
 * 
 * @param sockfd UNIX domain socket
 * @return int The file descriptor received; on error, return -1
 */
int recvfd(int sockfd);

#endif
```

```c title:server/unix.c
/* 本地 socket 通信 */
#include <string.h>
#include <sys/uio.h>
#include <stdlib.h>

#include "unix.h"

int sendfd(int sockfd, int fd) {
    struct msghdr hdr;
    memset(&hdr, 0, sizeof(struct msghdr));
    
    // 消息体：必须的 
    struct iovec iov[1];
    iov[0].iov_base = " ";
    iov[0].iov_len = 1;
    hdr.msg_iov = iov;
    hdr.msg_iovlen = 1;

    // 控制信息
    struct cmsghdr *cmsg = calloc(1, CMSG_LEN(sizeof(int)));
    if(cmsg == NULL) {
        return -1;
    }
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));  // 控制信息的总长度
    cmsg->cmsg_level = SOL_SOCKET; // 套接字层次的控制信息
    cmsg->cmsg_type = SCM_RIGHTS;  // 传递文件描述符
    *((int *)CMSG_DATA(cmsg)) = fd; // 文件描述符
    hdr.msg_control = cmsg;
    hdr.msg_controllen = cmsg->cmsg_len;

    // 发送信息
    if(sendmsg(sockfd, &hdr, 0) == -1) {
        return -1;
    }
    return 0;
}


int recvfd(int sockfd) {
    struct msghdr hdr;
    memset(&hdr, 0, sizeof(struct msghdr));

    // 接收消息体的缓冲区
    struct iovec iov[1];
    char buf[2];
    iov[0].iov_base = buf;
    iov[0].iov_len = 2;
    // 
    hdr.msg_iov = iov;
    hdr.msg_iovlen = 1;
    
    // 接收控制信息的缓冲区
    struct cmsghdr *cmsg = calloc(1, CMSG_LEN(sizeof(int)));
    if(cmsg == NULL) {
        return -1;
    }
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;

    // 将控制信息的缓冲区与 msghdr 关联
    hdr.msg_control = cmsg;
    hdr.msg_controllen = cmsg->cmsg_len;

    // 接收信息
    if(recvmsg(sockfd, &hdr, 0) == -1) {
        return -1;
    }

    return *((int *)CMSG_DATA(cmsg));
}
```

要特别注意的是，传递的 **文件描述符在数值上完全可能是不相等** 的，但是它们 **对应的文件对象确实是同一个**，自然文件读写偏移量也是共享的，和之前使用 `dup` 或者是先打开文件再 `fork` 的情况是一致的

为了让进程池中的可以接收父进程传递的打开文件描述，我们需要对进程池的数据结构和 `createProcessPoll()` 函数进行修改

```c title:server/worker.h

#ifndef WORKER_H
#define WORKER_H
#include <stdbool.h>
#include <sys/types.h>

/**
 * @brief 工作进程的状态的描述
 * 
 */
typedef enum {
    WORKER_STATE_IDLE,  // 空闲
    WORKER_STATE_BUSY   // 忙碌
} worker_state_t;


/**
 * @brief 工作进程的结构
 * 
 */
typedef struct {
    pid_t pid;             // 子进程的 pid
    worker_state_t state;  // 子进程的状态
    int sendSockFd;        // 与子进程通信的 socket 文件描述符
} worker_t;

/**
 * @brief Create process pool
 * 
 * @param workers An array that stores sub-process information.
 * @param maxlength Maximum length of workers
 * @return on success return 0, otherwise return -1
 */
int createProcessPoll(worker_t *workers, size_t maxlength);

/**
 * @brief The tasks handling function of the process
 * 
 * @param sockfd The socket file descriptor, which is used to receive tasks
 * @return on success return 0, otherwise return -1
 */
int handler(int sockfd);
#endif
```

```c title:server/worker.c
/* 与工作进程的相关操作 */
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "worker.h"
#include "unix.h"


int createProcessPoll(worker_t *workers, size_t maxlength) {
    for(int i = 0; i < maxlength; i++) {

        int sv[2];
        if(socketpair(AF_LOCAL, SOCK_STREAM, 0, sv) == -1) {
            return -1;
        }

        pid_t pid;
        switch (pid = fork())
        {
        case -1: // fork 失败
            return -1;
        case 0: // 子进程
            /* 关闭子进程的写入端 */
            if(close(sv[1]) == -1) {
                _exit(EXIT_FAILURE);
            }
            /* 让子进程陷入循环，不要脱离这里，否则子进程也会调用 fork() */
            while (true)
            {
                printf("PROCESS[PID %ld]: waiting for task, number=%d\n", (long)getpid(), i);
                // 从 sv[0] 中读取任务
                if(handler(sv[0]) == -1) {
                    fprintf(stderr, "handler() failed\n");
                }
                // 从 handler() 返回，说明任务处理完毕
                // 通过 sv[0] 将 pid 发送给 main 进程
                pid_t pid = getpid();
                if(send(sv[0], &pid, sizeof(pid_t), 0) == -1) {
                    fprintf(stderr, "send() failed\n");
                }
            }
            break;
        default:  // 父进程
            workers[i].pid = pid;                   // 记录子进程的 pid
            workers[i].state = WORKER_STATE_IDLE;   // 设置状态为 WORKER_STATE_IDLE
            workers[i].sendSockFd = sv[1];          // 记录用于给子进程传递任务的文件描述符
            break;
        }
    }
    return 0;
}

int handler(int sockfd) {
    // 读取任务
    int connfd = recvfd(sockfd);
    if (connfd == -1 || connfd == 0) {
        return -1;
    }
    printf("PROCESS[PID %ld]: connfd = %d\n", (long)getpid(), connfd);

    // 处理任务：这里只是简单的回显
    while (true)
    {
        char buf[BUFSIZ] = {0};
        ssize_t numRead = read(connfd, buf, BUFSIZ);
        if(numRead == -1) {
            return -1;
        }
        // 对端关闭连接
        if(numRead == 0) {
            break;
        }

        for(int i = 0; i < numRead; i++) {
            buf[i] = (char)toupper(buf[i]);
        }
        char *fmt = "PROCESS[PID %ld]: %s\n";
        char result[BUFSIZ + 100];
        int size = snprintf(result, BUFSIZ + 100, fmt, (long)getpid(), buf);

        if(write(connfd, result, size) != size) {
            return -1;
        }
    }
    // 关闭连接
    if(close(connfd) == -1) {
        return -1;
    }
    return 0;
}
```

> [!tip] 
> 
> + 进程池中的进程执行一个循环，等待任务从主进程传递过来
> + 接收任务，并执行
> + 当任务完成后，向主进程发送自己的 PID
> 

然后，在主进程中，通过 `sendfd()` 发送与客户端连接的对等套接字给进程池中的空闲进程

```c title:server/main.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/epoll.h>
#include <unistd.h>

#include "worker.h"
#include "tcp.h"
#include "epoll.h"
#include "unix.h"

#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"
#define WORKER_NUMBER 5

int main(int argc, char *argv[])
{
    if (argc > 1 && strcmp(argv[1], "--help") == 0)
    {
        fprintf(stderr, "Usage: %s [hostname] [service name] [worker number]\n", argv[0]);
        return 1;
    }
    // 获取命令行参数
    char *hostname = argc > 1 ? argv[1] : HOSTNAME;
    char *service = argc > 2 ? argv[2] : SERVICE;
    int worker_number = argc > 3 ? atoi(argv[3]) : WORKER_NUMBER;

    // 创建工作进程池
    worker_t *workers = calloc(worker_number, sizeof(worker_t));
    if (workers == NULL)
    {
        fprintf(stderr, "calloc() failed\n");
        return 1;
    }
    if (createProcessPoll(workers, worker_number) == -1)
    {
        fprintf(stderr, "createProcessPoll() failed\n");
        return 1;
    }

    // 创建监听套接字：构建地址结构体-> 创建套接字-> 绑定地址-> 监听
    // 调用封装好的创建监听套接字函数
    int sockfd = listenTCPSocket(hostname, service, PROTOCOL_IP);
    if (sockfd == -1)
    {
        fprintf(stderr, "listenTCPSocket() failed\n");
        return 1;
    }
    // 创建 epoll 实例
    int epfd = epoll_create(1024);
    if (epfd == -1)
    {
        fprintf(stderr, "epoll_create() failed\n");
        return 1;
    }

    // 将监听套接字添加到 epoll 实例中
    if (epoll_add(epfd, sockfd, EPOLLIN) == -1)
    {
        fprintf(stderr, "epoll_add() failed\n");
        return 1;
    }

    // 将工作进程的文件描述符添加到 epoll 实例中
    for (int i = 0; i < worker_number; i++)
    {
        if (epoll_add(epfd, workers[i].sendSockFd, EPOLLIN) == -1)
        {
            fprintf(stderr, "epoll_add() failed\n");
            return 1;
        }

        // 开启事件循环
        int max_length = 1024;
        struct epoll_event *events = malloc(sizeof(struct epoll_event) * max_length);
        while (true)
        {
            int readyNumber = epoll_wait(epfd, events, max_length, -1);
            if (readyNumber == -1)
            {
                fprintf(stderr, "Failed to wait for events\n");
                return 1;
            }
            for (int i = 0; i < readyNumber; i++)
            {
                if (events[i].data.fd == sockfd)
                {
                    // 有客户端连接
                    int connfd = accept(sockfd, NULL, NULL);
                    for (int i = 0; i < worker_number; i++)
                    {
                        // 寻找一个空闲的工作进程
                        if (workers[i].state == WORKER_STATE_IDLE)
                        {
                            // 将任务发送给工作进程
                            if (sendfd(workers[i].sendSockFd, connfd) == -1)
                            {
                                fprintf(stderr, "sendfd() failed\n");
                            }
                            // 设置工作进程状态为忙碌
                            workers[i].state = WORKER_STATE_BUSY;
                            close(connfd);
                            break;
                        }
                    }
                }
                else
                {
                    // 有工作进程完成任务
                    pid_t pid;
                    if (recv(events[i].data.fd, &pid, sizeof(pid_t), 0) == -1)
                    {
                        fprintf(stderr, "recv() failed\n");
                    }
                    for (int i = 0; i < worker_number; i++)
                    {
                        if (workers[i].pid == pid)
                        {
                            // 设置工作进程状态为空闲
                            workers[i].state = WORKER_STATE_IDLE;
                            break;
                        }
                    }
                }
            }
        }
    }
}
```

> [!tip] 主进程执行如下任务
> 
> + 首先创建一些列的子进程，并将子进程设置为空闲状态
> + 然后处理网络连接，使用 epoll 监视 LISTEN SOCKET 和 与进程池中进程的通信的 UNIX SOCKET
> + 每当有客户端连接的时候，就向进程池中的空闲检查传递连接 SOCKET 文件描述，并将进程修改为忙碌状态
> + 当主进程接收到子进程的通知时，将完成任务的进程设置为 空闲状态
> 

## 文件的传输

### 文件头

由于 TCP 是流式协议，消息没有边界。传输文件需要传递文件名和文件内容，这两个消息需要分开传递。因此，需要解决消息边界的问题。因此，我们定义一个 **头**，里面包含了 **文件名长度**，**文件名** 和 **文件长度**

```c title:server/worker.h
typedef struct {
	size_t filename_len;
	char *filename;
	off_t filesize;
} filehdr_t;
```

这个头应该首先发送给客户端，客户端才能知道消息的边界在何处，从而能够正确处理文件的接受

```c title:server/worker.h
/**
 * @brief Send file header
 * 
 * @param connfd Connection socket file descriptor
 * @param hdr File header
 * @return on success return 0, otherwise return -1
 */
int sendhdr(int connfd, const filehdr_t *hdr);
```

```c title:server/worker.c
int sendhdr(int connfd, const filehdr_t *hdr) {
    ssize_t ret = 0;
    // 发送文件名长度
    ret |= send(connfd, &hdr->filename_len, sizeof(hdr->filename_len), 0);
    // 发送文件名
    ret |= send(connfd, hdr->filename, hdr->filename_len, 0);
    // 发送文件大小
    ret |= send(connfd, &hdr->filesize, sizeof(hdr->filesize), 0);
    if(ret == -1) {
        return -1;
    }
    return 0;
}
```

### 发送文件内容

这样，当文件头信息传递给客户端之后，就可以开始传输文件内容

```c title:server/worker.h
/**
 * @brief Send file
 * 
 * @param connfd Connection socket file descriptor
 * @param path file path
 * @return on success return 0, otherwise return -1
 */
int sendfile(int connfd, const char *path);
```

首先，获取文件的大小并构建文件头，然后调用 `sendhdr()` 将文件头发送给客户端。最后，打开文件，循环读取文件的内容并发送给客户端

```c title:server/worker.c
int sendfile(int connfd, const char *path) {
    filehdr_t hdr;
    struct stat st;
    if(stat(path, &st) == -1) {
        return -1;
    }
    hdr.filename_len = strlen(path);
    hdr.filename = path;
    hdr.filesize = st.st_size;
    if(sendhdr(connfd, &hdr) == -1) {
        return -1;
    }

    int fd = open(path, O_RDONLY);
    if(fd == -1) {
        return -1;
    }
    while (true)
    {
        char buffer[BUFSIZ] = {0};
        ssize_t n = read(fd, buffer, BUFSIZ);
        if(n == -1) {
            return -1;
        }
        if(n == 0) {
            break;
        }

        if(sendn(connfd, buffer, n) == -1) {
            break;
        }
    }
    close(fd);
    return 0;
}
```

在这个结构中，可能存在 **部分写** 的问题。这里，我们定义了一个 `sendn()` 函数，包装了 `send()` 函数

```c title:server/worker.h
/**
 * @brief Handle partial write issue
 * 
 * @param connfd Connection socket file descriptor
 * @param buffer Data to be sent
 * @param len Data length
 * @return on success return 0, otherwise return -1
 */
int sendn(int connfd, const void *buffer, size_t len);
```

```c title:server/worker.c
int sendn(int connfd, const void *buffer, size_t len) {
    size_t total = 0;
    const char *ptr = (const char *)buffer;
    while(total < len) {
        ssize_t num = send(connfd, ptr + total, len - total, 0);
        if (num == -1) {
            // 如果被信号中断重启系统调用
            if(errno == EINTR) {
                continue;
            }
            return -1;
        }
        total += num;
    }
    return 0;
}
```

### 客户端接收文件

客户端在接收文件时，应该首先接收 **文件头**。

```c title:client/client.h
#ifndef CLIENT_T
#define CLIENT_T
#include <stddef.h>
#include <sys/types.h>

typedef struct {
    char *filename;
    size_t filename_len;
    off_t filesize;
} filehdr_t;

/**
 * @brief Receive file header
 * 
 * @param sockfd SOCKET file descriptor
 * @param hdr file header cache
 * @return on success return 0, otherwise return -1 
 */
int recvhdr(int sockfd, filehdr_t *hdr);
#endif
```

```c title:client/client.c
int recvhdr(int sockfd, filehdr_t *hdr) {
    if(hdr == NULL) {
        return -1;
    }
    int ret = 0;
    // 接收文件名长度
    ret |= recv(sockfd, &hdr->filename_len, sizeof(hdr->filename_len),0);
    // 接收文件名
    ret |= recv(sockfd, hdr->filename, hdr->filename_len, 0);
    // 接收文件大小
    ret |= recv(sockfd, &hdr->filesize, sizeof(hdr->filesize), 0);
    if(ret == -1) {
        return -1;
    }
    return 0;
}
```

得到文件头之后，可以创建并从网络中读取数据并写入文件了

```c title:client/main.c
#include <sys/types.h>
#include <sys/socket.h>
#undef __USE_XOPEN2K
#define __USE_XOPEN2K
#include <netdb.h>

#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "client.h"

#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"

int main(int argc, char *argv[]) {
    if(argc >  1 && strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <hostname> <service>\n", argv[0]);
        return 1;
    }
    char *hostname = argc > 1 ? argv[1]: HOSTNAME;
    char *service = argc > 2 ?  argv[2]: SERVICE;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = 0;
    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;
    struct addrinfo *result;
    if(getaddrinfo(hostname, service, &hints, &result) == -1) {
        fprintf(stderr, "getaddrinfo() failed\n");
        return 1;
    }
    int sockfd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if(sockfd == -1) {
        fprintf(stderr, "socket() failed\n");
        return 1;
    }
    if(connect(sockfd, result->ai_addr, result->ai_addrlen) == -1) {
        fprintf(stderr, "connect() failed\n");
        return 1;
    }
    freeaddrinfo(result);

    filehdr_t hdr;
    char filename[1024];
    hdr.filename = filename;
    if(recvhdr(sockfd, &hdr) == -1) {
        fprintf(stderr, "recvhdr() failed\n");
        return 1;
    }

    int fd = open(hdr.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(fd == -1) {
        fprintf(stderr, "open() failed\n");
        return 1;
    }
    char buf[BUFSIZ];
    while (true)
    {
        size_t len = BUFSIZ;
        if(recvn(sockfd, buf, &len) == -1) {
            fprintf(stderr, "recvn() failed\n");
            return 1;
        }
        if(len == 0) {
            break;
        }
        if(write(fd, buf, len) == -1) {
            fprintf(stderr, "write() failed\n");
            return 1;
        }
    }
    close(fd);
    close(sockfd);
    return 0;
}
```

## 零拷贝传输

服务端在发送文件时，首先从文件对象的缓冲区拷贝到用户空间的缓冲区，然后再从用户空间的缓冲区拷贝到对等 SOCKET 的发送缓冲区。这里不会对文件进行任何修改
 
 ![[Pasted image 20241128215758.png]]
 
对于只是简单复制，这种拷贝显然是一种浪费。由于 **文件缓冲区** 和 **SOCKET 发送缓冲区** 都在内核，如果可以直接将文件缓冲区中的内容拷贝到 SOCKET 发送缓冲区，那么就可以避免拷贝到用户空间。这称为 **零拷贝传输**

 ![[Pasted image 20241128220049.png]]

为了实现这样零拷贝传输，可以直接使用 `<sys/sendfile.h>` 中的 `sendfile()` 函数，也可以使用 [[内存映射]] 技术实现。[[SOCKET：高级主题]] 中，我们介绍了 `<sys/sendfile.h>` 中的 `sendfile()` 函数，由于该函数的使用存在诸多限制。因此，我们选择使用 **内存映射** 实现我们自定的 `sendfile()` 函数

```c title:server/worker.c
int sendfile(int connfd, const char *path) {
    filehdr_t hdr;
    struct stat st;
    if(stat(path, &st) == -1) {
        return -1;
    }
    hdr.filename_len = strlen(path);
    hdr.filename = path;
    hdr.filesize = st.st_size;
    if(sendhdr(connfd, &hdr) == -1) {
        return -1;
    }
    // 打开文件
    int fd = open(path, O_RDONLY);
    if(fd == -1) {
        return -1;
    }
    // 建立私有文件映射：不用担心文件内容会被修改
    char *filemap = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    // 将文件映射的虚拟内存区域当做缓冲区直接写入到 SOCKET 发送缓冲区
    if(sendn(connfd, filemap, st.st_size) == -1) {
        munmap(filemap, st.st_size);
        close(fd);
        return -1;
    }
    // 解除文件映射
    munmap(filemap, st.st_size);
    // 关闭文件
    close(fd);
    return 0;
}
```

