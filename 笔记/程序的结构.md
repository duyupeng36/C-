# 程序的结构

## 预处理器

在 [[基本概念]] 中使用过 `#include` 和 `#define` 两个预处理指令。这些指令都是由 **预处理器** 处理的

> [!tip]
> 
> 预处理器是编译工具链上的一个小工具，在编译前处理 C 程序
> 

预处理器是非常强大的，也是导致许多难以发现错误的原因。尽管 C 程序非常依赖预处理器，但是我们应当适度使用它

**预处理器的行为是由预处理指令控制的**。预处理器会读取输入的 `.c` 文件，然后根据预处理指令对 `.c` 文件进行修改，并输出修改后的 `.c` 文件

> [!tip] 预处理指令
> 
> 预处理指令是由`#`字符开头的一些命令。大多数预处理指令属于下面 $2$ 种类型
> 
> + **宏定义**：`#define` 指令定义一个宏，`#undefine` 指令删除一个宏定义
> + **文件包含**：`#include` 指令导致一个指定文件的内容包含到程序中
> + **条件编译**：`#if` `#ifdef` `#ifndef` `#elif` `#else` 和 `#endif`
>   

> [!tip] 预处理指令规则
> + 指令都以 `#` 开始。只要 `#` 之前是空白字符就行
> + 在指令的符号之间可以插入任意数量的空格或水平制表符
> + **指令总是在第一个换行符处结束**，除非明确地指明要延续，即使用续行符(`\`)完成续行
> + 指令可以出现在程序中的任何地方
> + 注释可以与指令放在同一行
>

### 宏定义


关于 **对象式宏** 和 **宏函数** 在 [[基本概念#第一个 C 程序#宏定义]] 中就已经介绍过了。这里我们不再重复

#### 宏定义专用运算符

宏定义可以包含两个专用的运算符：`#` 和 `##`。编译器不会识别这两种运算符，它们会在预处理时被执行

> [!tip] `#` 运算符 **将宏参数名转换为字符串字面值**

```c
#define PRINT_INT(n) printf(#n " = %d\n", n) /* #n 将会被转换为 "n" */
```

> [!tip] `##` 运算符可以 **将两个记号（如标识符）“粘合” 在一起**，成为一个记号

```c
#define MK_ID(n) i##n

int MK_ID(1);  // 创建标识符 i1
```

#### 预定义宏


C 语言有一些预定义宏，每个宏表示一个整型常量或字面串

| 预定义宏       | 描述                    |
| :--------- | --------------------- |
| `__LINE__` | 当前宏所在的行号              |
| `__FILE__` | 当前文件的名字               |
| `__DATE__` | 编译日期，格式为 `mm dd yyyy` |
| `__TIME__` | 编译时间，格式为 `hh:mm:s`    |
| `__STDC__` | 如果编译器符合 C 标准，那么值为 `1` |

C99 中新增了几个预定义宏

| 预定义宏                       | 描述                     |
| :------------------------- | ---------------------- |
| `__STDC_HOSTED__`          | 托管式实现，值为 1；独立式实现，则值为 0 |
| `__STDC_VERSION__`         | 支持的 C 标准版本             |
| `_STDC_IEC_559__`          | 是否 IEC 60559  浮点算术运算   |
| `__STDC_IEC_559_COMPLEX__` | 是否支持 IEC 60559 复数算术运算  |
| `__STDC_ISO_10646__`       |                        |
| `__VA_ARGS__`              | 可变宏参数                  |

### 条件编译

C 语言的预处理器可以识别大量用于支持 **条件编译** 的指令。条件编译是指根据预处理器所执行的测试结果来包含或排除程序的片段

```c
#if NAME

#endif
```

预处理器会测试 `NAME` 宏的值。如果 `NAME` 的值不是 $0$，则 `#if` 和 `#endif` 之间的语句将被包含的语句将被保留，否则 `#if` 和 `#endif` 之间(包括 `#if` 和 `#endif`) 的语句都将被预处理器删除

有时候，我们只需要检查某个宏是否被定义，而不需要知道其值。可以使用 `define` 运算符

```c
#if define(NAME)

#endif
```

> [!tip] `define(NAME)` 检查 `NAME` 宏是否被定义
> 
> 如果 `NAME` 被定义，则 `define(NAME)` 的值为 `1`；否则，值为 `0`
> 

为了简化上述，可以使用 `#ifdef` 或 `#ifndef`

```c
#ifdef NAME

#endif
```

> [!tip] `#ifdef NAME` 检查 `NAME` 是否有定义 

```c
#ifndef NAME

#endif
```

> [!tip] `#ifndef NAME` 检查 `NAME` 是否无定义

除了上述条件编译指令外，还有 `#elif` 和 `#else`；这些指令类似于 `if` 语句。下面给出了一个较为完整的条件编译指令

```c
#if 表达式 1 
	当表达式 1 非 0 时需要包含的代码 
#elif 表达式 2 
	当表达式 1 为 0 但表达式 2 非 0 时需要包含的代码 
#else 
	其他情况下需要包含的代码 
#endif
```

C23 新增了 `#elifdef` `#elifndef`  条件编译指令

### 其他指令


| 其他指令           | 描述                             |
| :------------- | :----------------------------- |
| `#error 消息`    | 预处理器遇见 `#error` 指令立即停止，并产生一条消息 |
| `#warning 消息	` | 预处理器遇见 `#warning` 指令产生一条消息     |
| `#line N`      | 改变程序行的编号                       |
| `#line N "文件"` | 指令后面的行会被认为来自文件，行号由 `n` 开始      |
| `#pragma 记号`   | 为要求编译器执行某些特殊操作提供了一种方法          |

## 多文件编程

虽然某些 C 程序小得足够放入一个单独的文件中，但是大多数程序不是这样的。程序由多个文件构成的原则更容易让人接受

常见的程序由多个 **源文件** 组成

> [!tip] **源文件** 包含 _函数的定义_ 和 _外部变量_
> 
> 程序可以分割成任意数量的 **源文件**。按惯例 C 程序的源文件以 `.c` 为扩展名 
> 

当把程序分割为几个源文件时，问题也随之产生了

> [!question] 
> 
> 某文件中的函数如何调用定义在其他文件中的函数呢？
> 
> 函数如何访问其他文件中的外部变量呢?
> 
> 两个文件如何共享同一个宏定义或类型定义呢？
> 

答案就将共享内容定义在 **头文件中**，并通过 `#include` 指令包含到源文件中去

> [!tip] **头文件** 包含可以 _在源文件之间共享的信息_
> 

### 头文件包含指令

`#include` 指令有两种形式

```c
#include <文件名.h>

#include "文件名.h"
```

`<文件名.h>` 指定头文件在系统头文件目录中查找，UNIX 通常在 `/usr/include` 中

`"文件名.h"` 指定头文件首先在当前目录搜索，然后再搜寻系统头文件目录

GCC 编译选项 `-I 路径` 可以指定头文件查找目录

### 共享宏定义和类型定义

大多数大型程序包含需要由几个源文件 **共享的宏定义和类型定义**。这些共享的定义应该放在 **头文件** 中

> [!tip]
> 
> 多个源文件共享的定义，就应该放在头文件中
> 


把宏定义和类型定义放在头文件中有许多显而易见的好处。首先，不把定义复制到需要它们的源文件中可以**节约时间**。其次，**程序变得更加容易修改**。改变宏定义或类型定义只需要编辑单独的头文件，而不需要修改使用宏或类型的诸多源文件。最后，**不需要担心由于源文件包含相同宏或类型的不同定义而导致的矛盾**

### 共享函数原型

假设源文件包含函数 `f` 的调用，而函数 `f` 是定义在另一个文件 `foo.c` 中的。调用没有声明的函数 `f` 是非常危险的

我们的第一个想法是在调用函数 `f` 的文件中声明它。这样可以解决问题，但是可能产生维护方面的“噩梦”。解决办法是显而易见的：**把函数 `f` 的原型放进一个头文件中，然后在所有调用函数f的地方包含这个头文件**

### 共享变量声明

为了共享函数，要把函数的定义放在一个源文件中，然后在需要调用此函数的其他文件中放置声明。共享外部变量的方法和此方式非常类似。

假设我在 `foo.c` 文件中定义了外部变量 `i`

```c
int i;  // 在 foo.c 中定义的外部变量
```

为了能在另一个文件 `bar.c` 中使用 `foo.c` 中定义的外部变量 `i`，就需要在 `bar.c` 中声明变量，关键字 `extern` 帮助我们声明变量，而非定义

```c
extern int i;
```

`extern` 告诉编译器，变量 `i` 是在程序中的其他位置定义的（很可能是在不同的源文件中），因此不需要为 `i` 分配空间

> [!tip] 定义与声明
> 
> + **定义**：编译器为变量留出内存空间
>   
> + **声明**：编译器不会为变量留出内存空间，而是在程序的其他源文件中寻找定义
> 

### 头文件保护

如果源文件包含同一个头文件两次，那么可能产生编译错误。当头文件包含其他头文件时，这种问题十分普遍

两次包含同一个头文件不总是会导致编译错误。如果文件只包含宏定义、函数原型和/或变量声明，那么不会有任何困难。然而，**如果文件包含类型定义，则会导致编译误**。

安全起见，保护全部头文件避免多次包含可能是个好主意，那样的话可以在稍后添加类型定义，不用冒因忘记保护文件而可能产生的风险

```c
#ifndef BOOLEAN_H 
#define BOOLEAN_H 
 
#define TRUE 1 
#define FALSE 0 
typedef int Bool; 
 
#endif
```
