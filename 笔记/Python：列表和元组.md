# 列表和元组

Python 提供的内建数据结构 **列表** 和 **元组**，这两个是 [[线性表]] 的顺序实现。在 Python 中，列表和元组成为 **序列**

> [!tip] 
> 
> 序列分为两种 **可变序列** 和 **不可变序列**
> + 可变序列：序列中的元素可以被修改。 列表是典型的可变序列
> + 不可变序列：序列中的元素不可以被修改。元组是典型的不可变序列
> 

## 列表

列表是 Python 中常用的数据结构，其类型是 `list`。在 Python 中创建 `list` 对象方式非常简单

> [!tip] 字面值：创建列表对象最常用的方式
> 
> Python 中 `list` 对象的字面值形如 `[value1, value2, ...]`
> + `list` 中的每一项由逗号(`,`) 分隔，并被方括号(`[]`) 包围 
> + `value` 的类型可以是不同
> 
> 构造 `list` 最常用的方式就是使用字面值 `[]`，只要 `[]` 出现 Python 解释器就会创建一个全新的 `list` 对象
> 

> [!tip] 构造函数
> 
> 使用构造函数 `list()` 或者 `list(iterable)` 可以创建一个列表
> + 列表中的元素要么为空，要么来自 `iterable`  
> 
> `iterable` 是一种 **可迭代对象**，如果 `iterable` 本身就是 `list`，那么就会返回 `iterable` 的副本
> 

```python
>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
>>> data = ["duyupeng", 28]
>>> data
['duyupeng', 28]
```

> [!attention] 如何才能做到保存不同类型的值？
> 
> 我们知道顺序表中存储的是相同类型的元素。Python 中列表也不能违背这个规则，那么它是如何做到保存不同类型的值的呢？
> 
>  对于不同类型的数据，占用的内存空间可能不相同。但是，当数据保存在内存中之后，内存地址就可以标识该数据。对于一个固定的系统，内存地址的长度是固定的，Python 就是在列表中 **存储其对象的内存地址来存储不同类型的对象的**
> 
> 使用内存地址表示对象的这种方式称为引用。不仅仅是在列表这样，Python 中的变量也是只保存一个对象所在的内存地址，而不代表该对象所在的位置
> 
> ![[Pasted image 20250113124805.png]]
> 

### 通用序列操作

大多数序列，包括可变序列和不可变序列都支持下表中的操作

| 运算                   | 结果                                           |
| :------------------- | :------------------------------------------- |
| `x in s`             | 如果序列 `s` 中的某一项等于 `x`，则结果为 `True`，否则为 `False` |
| `x not in s`         | 如果序列 `s` 中的某一项等于 `x`，则结果为 `False`，否则为 `True` |
| `s + t`              | 序列 `s` 与序列 `t` 进行拼接操作                        |
| `s * n` 或者 `n * s`   | 序列 `s` 与自身拼接 `n` 次                           |
| `s[i]`               | 索引取值，即序列 `s` 中第 `i`  项                       |
| `s[i:j]`             | 切片，即序列 `s` 从 `i` 到 `j` 的切片                   |
| `s[i:j:k]`           | 切片，即序列 `s` 从 `i` 到 `j`，步长为 `k` 的切片           |
| `len(s)`             | 获取序列 `s` 的长度                                 |
| `min(s)`             | 获取序列 `s` 中的最小值                               |
| `max(s)`             | 获取序列 `s` 中的最大值                               |
| `s.index(x[,i[,j]])` | 元素 `x` 在序列 `s` 中首次出现的位置。在索引 `i` 之后，索引 `j` 之前 |
| `s.count(x)`         | 统计元素 `x` 在序列中出现的次数                           |

```python
>>> squares = [1,4,9,16,25]
>>> squares
[1, 4, 9, 16, 25]
>>> squares[0]  # 索引操作将返回条目
1
>>> squares[-1] # 支持负索引
25
>>> squares[-3:]  # 最后三个元素切片
[9, 16, 25]
```

> [!tip] 负索引
> 
> 下图展示了正索引与负索引之间的关系：$正索引=len(序列)+负索引$
> 
> ![[Pasted image 20250113132630.png]]
> 
> - **正索引**：从 $0$ 开始编号，到 `len(list) - 1` 为止。`len(list)` 表示列表中的元素个数
> - **负索引**：从 $-1$ 开始编号，到 `-len(list)` 为止

索引操作，必须满足给定的范围，对于越界的索引，会触发 `IndexError` 异常

```python
>>> squares[4]
25
>>> squares[5]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

### 列表方法

#### 修改元素

列表作为可变序列，其内容是可以改变的

```python
>>> cubes = [1, 8, 27, 65, 125]  # 这里有点问题
>>> 4 ** 3  # 4 的立方是 64，不是 65！
64
>>> cubes[3] = 64  # 替换错误的值
>>> cubes
[1, 8, 27, 64, 125]
```

#### 添加元素

还可以通过使用 `list.append()` 方法在列表的末尾添加新条目

```python
>>> cubes.append(216)    # 添加 6 的立方
>>> cubes.append(7 ** 3) # 添加 7 的立方
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
```

> [!tip] 
> 
> `list.append()` 方法如果不触发列表的扩容机制，则其时间复杂度为 $O(1)$
> 

假设已经有一个可迭代对象，如果需要将这个可迭代对象中的元素追加到列表末尾，可以使用 `list.extend(iterable)` 方法。该方法将 `iterable` 中的每个元素按顺序追加到列表末尾

```python
>>> squares
[]
>>> squares.extend([1, 4, 9, 16, 25, 36, 49])
>>> squares
[1, 4, 9, 16, 25, 36, 49]
```

> [!tip] 
> 
> `list.extend(iterable)` 方法如果不触发列表的扩容机制，则其时间复杂度为 $O(n)$
> 

#### 删除元素

删除列表中的元素也是允许的。使用 `del` 语句可以删除列表中的某个元素

```python
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
>>> del cubes[-1]  # 删除最有一个元素
>>> cubes
[1, 8, 27, 64, 125, 216]
```

列表对象提供了如下几种方法用于删除列表中的元素

`list.pop(index=-1)`: 指定`index` 索引删除元素, 默认删除列表末尾。 并返回删除的元素。当列表中无元素, 抛出 `IndexError`

> [!note] 实现细节
> 将 `index` 之后的元素向前移动一位。平均时间复杂度为 $O(n)$
> - 最好情形是删除列表最后一个元素，最好时间复杂度为 $O(1)$

```python
>>> cubes
[1, 8, 27, 64, 125, 216]
>>> cubes.pop()  # 删除最后一个元素
216
>>> cubes.pop(1) # 删除索引为 1 的元素
8
>>> cubes
[1, 27, 64, 125]
```

`list.remove(value)`: 指定 `value` 值删除. 如果没有这样的元素，则抛出 `ValueError` 异常

> [!note] 实现细节
> 先找到 `value`，将 `value` 之后的元素向前移动一位。平均时间复杂度为 $O(n)$

```python
>>> squares
[1, 4, 9, 16, 25]
>>> squares.remove(9)  # 删除元素 9
>>> squares
[1, 4, 16, 25]
```

`list.clear()`: 清空列表中的元素

> [!note]  实现细节
> 会将 `list` 对象的长度设置为 $0$，`list` 中的每个元素的引用计数减 $1$
> 

```python
>>> squares
[1, 4, 16, 25]
>>> squares.clear()
>>> squares
[]
```

#### 排序和翻转

列表提供了下面两个方法用于 **原地排序** 和 **原地反转** 列表

`list.sort(*,key=None, reverse=False)`: 排序, `key`用于指定元素在排序前的操作；`reverse`用于控制升序或降序。默认为升序排列

> [!tip] 
> 
> `sort` 方法采用 [[LIPIcs.ESA.2018.4.pdf]]  中的排序算法，于 2002 年由  Tim Peters 设计。该算法从 **归并排序** 和 **插入排序** 改进而来，具有如下特性
> - 稳定：相同元素在排序后的位置关系不变
> - 快速：最坏时间复杂度为 $O(n\log n)$，最好时间复杂度为 $O(n)$
> - 空间消耗：空间复杂度为 $O(n)$
> 

`list.reverse()` : 原地反转列表

```python
>>> li
[-1, 1, 2, 3, 4, 'h', 'e', 'l', 'l', 'o']
>>> li.sort(key=str, reverse=True)  # 降序排列
>>> li
['o', 'l', 'l', 'h', 'e', 4, 3, 2, 1, -1]
>>> li.sort(key=str)  # 升序排列
>>> li
[-1, 1, 2, 3, 4, 'e', 'h', 'l', 'l', 'o']
>>> li.reverse()  # 反转
>>> li
['o', 'l', 'l', 'h', 'e', 4, 3, 2, 1, -1]
```

### 复制



## 元组








