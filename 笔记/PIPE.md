# PIPE

**管道(PIPE) 是 UNIX 系统上最古老的 _进程间通信(IPC)_ 方法**，它在 20 世纪 70 年代早期 UNIX 的第三个版本上就出现了。管道为一个常见需求提供了一个优雅的解决方案：给定两个运行不同程序的进程，在 shell 中如何让一个进程的输出作为另一个进程的输入呢？

UNIX/Linux 提供两种类型管道：**PIPE** 和 **Named PIPE**

> [!tip] PIPE：**无名管道**，也称为管道
> 
> 管道可以用来在 **相关进程之间传递数据**。例如，父子进程之间
> 

对于不相关的进程，即独立允许的两个进程，它们之间想要通信，可以借助 Named PIPE

> [!tip] Named PIPE：**有名管道**，也称为 **FIFO**
> 
> FIFO 是 PIPE 概念的一个变体，它们之间的一个重要差别在于 **FIFO 可以用于任意进程间的通信**
> 
> 借助文件系统，FIFO 可以被任何进程使用
> 

## 概念

每个 shell 用户都对在命令中使用 **管道** 比较熟悉，如下面这个 **统计一个目录中文件的数目的命令** 所示

```shell
ls | wc -l
```

为执行上面的命令，shell 会创建了两个进程来分别执行 `ls` 和 `wc`

> [!tip] 
> 
> 创建进程来指向程序是通过使用 `fork()` 和 `exec()` 来完成的。详细参考 [[进程创建]] 和 [[程序执行]]
> 

下图展示了这两个进程是如何使用管道的

![[Pasted image 20241029232742.png]]

> [!tip] 
> 
> 管道与 [[栈和队列#队列]] 的概念非常相似，一端用于写入，另一端用于读取。可以将管道看成是一个 _铅管_，**它允许数据从一个进程流向另一个进程**
> 

两个进程都连接到了管道上，这样写入进程(`ls`) 就将其标准输出(`fd 1`) 连接到了管道的写入端，读取进程(`wc`) 就将其标准输(`fd 0`) 连接到管道的读取端。使用 [[深入文件 IO#复制文件描述符]] 操作完成

> [!tip] 
> 
> 这两个进程并不知道管道的存在，它们只是从标准文件描述符中读取数据和写入数据
> 

### 通信方式

> [!tip] 单工：消息只能单向传输
> 
> 如果消息只能从 $A$ 端发送到 $B$ 端，而 $B$ 端不能发送到 $A$ 端
> 

> [!tip] 半双工：消息单向传输，但是可以反向
> 
> 消息或者从 $A$ 端发送到 $B$ 端，或者从 $B$ 端发送到 $A$ 端，它们不能同时进行
> 

> [!tip] 全双工：消息可以双向传输
> 
> 如果消息可以从 $A$ 端发送到 $B$ 端，同时也可以从 $B$ 端发送到 $A$ 端
> 

### 管道特征

PIPE 和 FIFO 具有相似的特征

> [!tip] 管道是一个 **字节流**
> 
> 字节流意味着管道中的消息不存在 **边界** 的概念。因此，读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是什么
> 
> **管道传递的数据是 _顺序的_**。读进程读取消息的顺序和写进程写入消息的顺序是一样的
> 
> 在管道中无法使用 `lseek()` 进行随机访问
> 
> 如果需要在管道中实现 **离散消息** 的概念，就不行 **自行定义数据传输协议**。如果确实要发送离散消息，可以选择其他的 IPC 机制，例如 [[System V 消息队列]] 等
> 

> [!tip] 从管道中读取数据
> 
> 如果 **读取管道中没有数据**，那么读进程会被 **阻塞** 直到写进程写入至少 $1$ 字节为止
> 
> 如果 **写入进程关闭了管道**，读进程在读取完管道中剩余字节后就会看到 `EOF`，即 `read()` 返回 $0$
> 

> [!tip] 写入不超过 `PIPE_BUF` 字节的操作是原子的
> 
> 如果 **多个进程写入同一个管道**，那么如果它们在一个时刻写入的数据量不超过  `PIPE_BUF` 字节，那么就可以确保写入的数据不会发生相互混合的情况
> 
> SUSv3 要求 `PIPE_BUF` 至少是 `_POSIX_PIPE_BUF`($512$)。实现应该定义 `PIPE_BUF`，通常在 `<limits.h>` 或者允许调用 `fpathconf(fd, _PC_PIPE_BUF)` 获取。不同的实现 `PIPE_BUF` 的值不同
> + FreeBSD 6.0 中，`PIPE_BUF` 的值为 $512$
> + Tru64 5.1 中，`PIPE_BUF` 的值为 $4096$
> + Solaris 8 中，`PIPE_BUF` 的值为 $5120$
> 
> **在 Linux 上，`PIPE_BUF` 的值为 $4096$**
> 
> 当写入管道的数据块的大小超过了 `PIPE_BUF` 字节，那么内核可能会将数据 **分割成几个较小的片段** 来传输，在读者从管道中消耗数据时再附加上后续的数据
> 
> + `write()` 调用会 **阻塞** 直到管道可以被写入为止
> 
> 如果 **有多个写入进程**，那么大数据块的写入可能会被分解成任意大小的段（可能会小于 `PIPE_BUF` 字节），并且可能会出现与其他进程写入的 **数据交叉** 的现象
> 
> 如果 **读进程关闭了通道**，此时 **写进程向管道写入数据** 时，内核会向写进程发送 `SIGPIPE` 信号从而导致写进程异常退出
> 

> [!tip] 管道是单向的
> 
> 管道中数据传递方向是单向的(**单工**)。管道的一段用于写入，另一端则用于读取
> 
> FIFO 是 **半双工** 的，在打开 FIFO 时确定消息传递的方向
> 
> 某些 UNIX/Linux 实现上，管道是双向的，但是这不符合 UNIX 任何标准
> 

> [!tip] 管道容量是有限的
> 
> **管道其实是一个在内核内存中维护的缓冲区**，这个缓冲区的存储能力是有限的。一旦被填满之后，后续向管道写入的操作就会被阻塞直到读进程从管道中移除数据
> 
> SUSv3 并没有规定管道的存储能力。在 Linux < 2.6.11 前，管道的存储能力与系统分页大小一样(x86-32 上是 $4096$ 字节)。**在 Linux >= 2.6.11，管道的存储能力是 $65536$ 字节** 
> 


> [!attention] 总结
> 管道是一个字节流，管道的消息没有边界
> 
> ---
> 默认情况下，从管道中读取数据时，如果管道中没有数据，`read()` 操作阻塞
> + 如果管道 **写入端已关闭**，`read()` 将管道中剩余数据读取完毕后， 立即返回 $0$
>  
> ---
> 写入管道时，如果写入数据小于或等于 `PIPE_BUF` 字节，那么 `write()` 操作是原子的。在 Linux 上，`PIPE_BUF` 为 $4096$
> + 如果一次写入超过 `PIPE_BUF` 字节，内核会分割写入的字节。如果 **管道文件的缓冲区** 中有数据，`write` 阻塞 
> + 如果 **读取端已关闭**，那么写入端调用 `write()` 写入数据时内核会向写入端发送 `SIGPIPE` 信号，从而导致进程异常退出 
> 
> ---
>
> 管道容量是有限的。Linux >= 2.6.11 管道的容量是 $65536$ 字节
> + **管道被填满之后，`write()` 会阻塞**，直到读进程将管道中的数据读走 
> 

## PIPE

`pipe()` 系统调用创建一个新管道

```c
#include <unistd.h>

int pipe(int filedes[2]);
/* 成功返回 0， 失败返回 -1*/
```

成功的 `pipe()`调用会在数组 `filedes` 中返回两个打开的文件描述符，分别表示 PIPE 的两端

> [!tip] `filedes[0]` 代表读取端，只读取数据

> [!tip] `filedes[1]` 代表写入端，只写入数据

与所有文件描述符一样，可以使用 `read()` 和 `write()` 系统调用来在管道上执行 I/O 操作。一旦向管道的写入端写入数据之后立即就能从管道的读取端读取数据

管道上的 `read()` 调用会读取的数据量为所请求的字节数与管道中当前存在的字节数两者之间较小的那个

> [!important] 
> 
> 管道为空时 `read()` 阻塞，直到另一个进程在管道写入端写入数据
> 

也可以在管道上使用 `stdio` 函数(`printf()`、`scanf()`等)，只需要首先使用 `fdopen()` 获取一个与 `filedes` 中的某个描述符对应的文件流即可

> [!attention] 
> 
> 此时，需要注意 `stdio` 缓冲问题，参考 [[进程终止#fork() stdio 缓冲区和 _exit() 的交互]]
> 

下图描述了使用 `pipe()` 创建完管道之后的情况，其中调用进程通过文件描述符引用了管道的两端

![[Pasted image 20241104181048.png]]

在单个进程中管道的用途不多。一般来讲都是 **使用管道让两个进程进行通信**。为了让两个进程通过管道进行连接，在调用完 `pipe()` 之后可以调用 `fork()`。在 `fork()` 期间，**子进程会继承父进程的文件描述符的副本**

> [!important] 关闭未使用的文件描述符
> 
> 调用 `fork()` 之后，其中 **一个进程应该立即关闭管道的写入端** 的描述符，**另一个则应该关闭读取端** 的描述符
> 
> 如果父进程需要向子进程传输数据，那么它就会关闭管道的读取端的描述符  `filedes[0]`，而子进程就会关闭管道的写入端的描述符 `filedes[1]`
> 

如下图展示了使用管道来将数据从父进程传输到子进程

![[Pasted image 20241104181703.png]]

> [!attention] 父子进程从同一个管道中读取数据会造成数据竞争
> 
> 让父进程和子进程都能够 **从同一个管道中读取和写入数据** 这种做法并不常见的一个原因是如果 **两个进程同时试图从管道中读取数据**，那么就 **无法确定哪个进程会首先读取成功**，从而造成 **数据竞争**
> 
> 为了解决这种数据竞争，可以采用进程同步技术；或者创建两个管道，在两个进程之间发送数据的两个方向上各使用一个
> 

### PIPE 允许相关进程间的通信

**管道** 可以用于任意两个或更多 **相关进程之间的通信**，只要在创建子进程的系列  `fork()` 调用之前 **通过一个共同的祖先进程创建管道即可**

> [!tip] 
> 
> **管道可用于一个进程和其孙子进程之间的通信**。第一个进程创建管道，然后创建子进程，接着子进程再创建第一个进程的孙子进程
> 
> **管道通常用于两个兄弟进程之间的通信**，它们的 **父进程创建了管道**，然后 **创建两个子进程**
> 

### 关闭未使用 PIPE 文件描述符

关闭未使用 PIPE 文件描述符不仅仅是为了 **确保进程不会耗尽其文件描述符的限制**。此外，还有另一个重要的原因

> [!tip] 为了让读者看到文件结束 EOF
> 
> 从 PIPE 中读取数据的进程会关闭其持有的 PIPE 的写入描述符，这样当其他进程完成输出并关闭其写入描述符之后，读者就能够看到文件结束
> 

如果读取进程没有关闭 PIPE 的写入端，那么在其他进程关闭了写入描述符之后，读者也不会看到文件结束，即使它读完了管道中的所有数据

> [!warning] 
> 
> 由于读取进程没有关闭管道的写入端，此时读取进程调用 `read()` 将会阻塞以等待数据，这是因为 **内核知道至少还存在一个 PIPE 的写入描述符打开着**，即 **读取进程自己打开了这个描述符(PIPE 的写入端)**
> 

写入进程关闭其持有的 PIPE 的读取描述符是出于不同的原因。当一个进程试图向一个 PIPE 中写入数据但没有任何进程拥有该 PIPE 的打开着的读取描述符时，内核会向写入进程发送一个 `SIGPIPE` 信号

> [!tip] 
> 
> PIPE 没有打开的读取文件描述符，当进程向该 PIPE 写入数据时，内核会向进程发送 `SIGPIPE` 信号
> 

在默认情况下，这个信号会杀死一个进程。但进程可以捕获或忽略该信号，这样就会导致 PIPE 上的 `write()` 操作因 `EPIPE` 错误（已损坏的管道）而失败。收到 `SIGPIPE` 信号或得到 `EPIPE` 错误对于标示出 PIPE 的状态是有用的，这就是为何需要关闭 PIPE 的未使用读取描述符的原因

> [!warning] 关闭 PIPE 的未使用读取描述符的原因
> 
> 如果 **写入进程没有关闭 PIPE 的读取端**，那么即使在 **其他进程已经关闭了 PIPE 的读取端** 之后，**写入进程仍然能够向 PIPE 写入数据**，最后写入进程会将数据充满整个管道，后续的写入请求会被永远阻塞
> 

关闭 PIPE 未使用文件描述符的最后一个原因是 **只有当所有进程中 _所有_ 引用一个 PIPE 的文件描述符被 _关闭_ 之后才会销毁该管道以及释放该管道占用的资源** 以供其他进程复用。此时，管道中所有未读取的数据都会丢失。


