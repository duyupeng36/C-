# 网盘：一期

网盘项目是一个典型的 **C/S 应用程序**。整个应用程序分为 **服务端** 和 **客户端**。服务端可以处理多个客户端连接，并接受客户端发送的请求

![[Pasted image 20250109181738.png]]

客户端可以发送下列 $8$ 个请求

| 请求      | 描述           |
| :------ | :----------- |
| `cd`    | 切换当前目录       |
| `pwd`   | 显示当前工作目录     |
| `ls`    | 列出指定目录下的所有文件 |
| `puts`  | 上传文件         |
| `gets`  | 下载文件         |
| `rm`    | 删除文件         |
| `mkdir` | 创建目录         |
| `rmdir` | 删除目录         |
| `quit`  | 退出客户端        |

网盘项目需要管理不同用户的文件，因此不同用户的文件需要存储在不同的目录中。为了实现这个目的，我们在 `$HOME` 目录中创建一个 `netdisk` 目录。在 `$HOME/netdisk` 目录中 **为每个用户建立一个与用户名相同的目录** 。假设存在两个用户 `dyp` 和 `mike`，那在 `$HOME/netdisk` 中就会存在两个目录

```shell
➜  ~ tree netdisk
netdisk
├── dyp      # 存储 dyp 用户的文件
└── mike     # 存储 mike 用户的文件

3 directories, 0 files
```

用户通过客户端登陆网盘服务器之后，客户端就会展示该用户的根目录 `/`

> [!tip] 
> 
> 也就是说，客户端展示的目录 `/` 代表了服务端的 `$HOME/netdisk/用户名`
> 

## 客户端的职责

客户端需要完成 **连接服务端**、**接受用户输入**、**解析指令**。

### 连接服务端

客户端与服务的建立连接需要执行：**构建地址结构** 和 **调用 `connect()` 系统调用**。我们将这两部封装为一个函数 `tcp_connect()`

```c title:inclue/tcp.h
#ifndef TCP_H
#define TCP_H
#include <sys/socket.h>
#include <netdb.h>

/**
 * @brief Establish a connection with the server
 * 
 * @param hostname Host name of server
 * @param service  Port number of the server
 * @return int    On success, return the socket file descriptor, otherwise -1
 */
int tcp_connect(const char *hostname, const char *service);

#endif  // TCP_H
```

```c title:src/tcp.c
// 库/系统调用的头文件
#include <stddef.h>
#include <unistd.h>

// 自定义头文件
#include <tcp.h>

int tcp_connect(const char *hostname, const char *service) {
    if(hostname == NULL || service == NULL) {
        // 输出日志
        return -1;
    }

    struct addrinfo hints = {
        .ai_flags = AI_NUMERICHOST | AI_NUMERICSERV,
        .ai_family = AF_INET,
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = 0,
    };

    struct addrinfo *res;

    // 解析地址
    if(getaddrinfo(hostname, service, &hints, &res) != 0) {
        // 输出日志
        return -1;
    }

    // 创建套接字
    int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if(sockfd == -1) {
        // 输出日志
        freeaddrinfo(res);
        return -1;
    }
    
    // 建立连接
    if(connect(sockfd, res->ai_addr, res->ai_addrlen) == -1) {
        // 输出日志
        close(sockfd);
        freeaddrinfo(res);
        return -1;
    }
    // 释放 addrinfo 结构
    freeaddrinfo(res);
    return sockfd;
}
```

将 `tcp_connect()` 接入到客户端主程序中

```c title:main.c
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <unistd.h>

#include <tcp.h>

#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"

int main(int argc, char *argv[]) {
    if(argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)) {
        printf("Usage: %s <hostname> <service>\n", argv[0]);
        printf("        - hostname: Host name of server\n");
        printf("        - service: Port number of the server\n");
        printf("Example: %s %s %s\n", argv[0], HOSTNAME, SERVICE);
        return 0;
    }

    const char *hostname = argc > 1 ? argv[1] : HOSTNAME;
    const char *service = argc > 2 ? argv[2] : SERVICE;

    // 与服务端建立连接
    int sockfd = tcp_connect(hostname, service);
    if(sockfd == -1) {
        // 连接失败
        return -1;
    }
    // ...
}
```

### 接受用户的输入

客户端每次只会响应一个命令，在命令执行过程中，我们不希望在命令执行过程中通过 `Ctrl + C (SIGINT )` 和 `Ctrl + \ (SIGQUT)`  直接终止客户端，而是要等待所有命令执行完成后才终止。现在，我们只是简单忽略这两个信号，等客户端功能完成后才设计退出流程

```c title:main.c hl:16-19
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <unistd.h>
#include <signal.h>

#include <tcp.h>

#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"

int main(int argc, char *argv[]) {

    // 忽略 SIGINT 信号
    signal(SIGINT, SIG_IGN);
    // 忽略 SIGQUIT 信号
    signal(SIGQUIT, SIG_IGN);

    if(argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)) {
        printf("Usage: %s <hostname> <service>\n", argv[0]);
        printf("        - hostname: Host name of server\n");
        printf("        - service: Port number of the server\n");
        printf("Example: %s %s %s\n", argv[0], HOSTNAME, SERVICE);
        return 0;
    }

    const char *hostname = argc > 1 ? argv[1] : HOSTNAME;
    const char *service = argc > 2 ? argv[2] : SERVICE;

    // 与服务端建立连接
    int sockfd = tcp_connect(hostname, service);
    if(sockfd == -1) {
        // 连接失败
        perror("tcp_connect");
        return -1;
    }
    // ...
}
```

下面处理客户端如何输入命令的

```c title:inclue/cmd.h
#ifndef CMD_H
#define CMD_H

#include <stdio.h>

/**
 * @brief Read command from standard input
 * 
 * @param buf A buffer for storing commands.
 * @param size The size of the buffer.
 * @param prompt The prompt message.
 * @return int on success, return number of characters read. On error, return -1.
 */
int cmd_read(char * restrict buf, size_t size, const char * restrict prompt);

#endif // CMD_H
```

```c title:src/cmd.c
#include <cmd.h>

int cmd_read(char * restrict buf, size_t size, const char * restrict prompt) {
    printf("%s", prompt);
    size_t len = 0;
    while (len < size - 1 && (buf[len] = getchar()) != '\n') {
        len++;
    }
    buf[len] = '\0';
    return len > 0 ? len : -1;
}
```

### 解析指令

在客户端中，我们按照下面的方式输入指令

```shell
cmd [options] [args]
```

> [!tip]
> 
> `cmd` 这是需要执行的命令
> 
> 命令可能需要选项开启额外的功能。选项按照 Linux shell 选项提供
> 
> 命令还可能需要参数
> 

客户端需要从命令字符串中将 **命令本身**、**命令选项** 以及 **命令参数** 提取出来。根据命令调用对应的函数与服务端进行通信

```c title:include/cmd.h
#ifndef CMD_H
#define CMD_H

#include <stdio.h>

/**
 * @brief Parse command into arguments
 * 
 * @param cmd The command string, eg. "ls -l -a" 
 * @return char** A pointer to an array, which contains a pointer to each argument. For failed, return NULL.
 */
char ** cmd_parse(const char *cmd);


/**
 * @brief execute command, which is generated by cmd_parse.
 * 
 * @param args An array of arguments, which is generated by cmd_parse.
 */
void cmd_exec(char **args);

/**
 * @brief free the memory of arguments, which is generated by cmd_parse.
 * 
 * @param args An array of arguments, which is generated by cmd_parse.
 */
void cmd_free(char **args);
#endif // CMD_H
```

```c title:src/cmd.h
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include <cmd.h>

char ** cmd_parse(const char *cmd) {

    // 跳过前导空白字符串
    while(isspace(*cmd)) {
        cmd++;
    }
    // 计算参数个数
    int argc = 0;

    int i = 0;
    while (cmd[i] != '\0')
    {
        // 跳过非空白字符
        while(!isspace(cmd[i]) && cmd[i] != '\0') {
            i++;
        }
        // 参数个数 +1
        argc++;
        // 跳过当前空白字符
        while(isspace(cmd[i]) && cmd[i] != '\0') {
            i++;
        }
    }
    // printf("argc = %d\n", argc);
    // 分配参数数组
    char **argv = (char **)malloc((argc + 1) * sizeof(char *));
    if(argv == NULL) {
        return NULL;
    }
    
    // 解析参数
    argc = 0;
    const char *star = cmd;
    while (*cmd)
    {
        // 跳过前导非空白字符
        while (!isspace(*cmd) && *cmd != '\0') {
            cmd++;
        }
        // 分配存储参数的内存空间
        argv[argc] = (char *)malloc((cmd - star + 1) * sizeof(char));
        // 分配失败
        if(argv[argc] == NULL) {
            // 释放之前分配的内存
            for(int j = 0; j < argc; j++) {
                free(argv[j]);
            }
            free(argv);
            return NULL;
        }
        // 复制参数
        strncpy(argv[argc], star, cmd - star);
        argv[argc][cmd - star] = '\0';
        // 参数个数 +1
        argc++;
        // 跳过当前空白字符
        while(isspace(*cmd) && *cmd != '\0') {
            cmd++;
        }
        // 记录下一个参数的起始位置
        star = cmd;
    }
    argv[argc] = NULL;
    return argv;
}


void cmd_exec(char **args) {
    for(char **p = args; *p != NULL; p++) {
        printf("%s\n", *p);
    }
}

void cmd_free(char **args) {
    for(char **p = args; *p != NULL; p++) {
        free(*p);
    }
    free(args);
}
```

> [!tip] 
> 
> 由于尚未实现服务端，这里 `cmd_exec()` 仅仅用作占位
> 

## 服务端职责






