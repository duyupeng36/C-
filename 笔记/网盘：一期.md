# 网盘：一期

网盘项目是一个典型的 **C/S 应用程序**。整个应用程序分为 **服务端** 和 **客户端**。服务端可以处理多个客户端连接，并接受客户端发送的请求

![[Pasted image 20250109181738.png]]

客户端可以发送下列 $8$ 个请求

| 请求      | 描述           |
| :------ | :----------- |
| `cd`    | 切换当前目录       |
| `pwd`   | 显示当前工作目录     |
| `ls`    | 列出指定目录下的所有文件 |
| `puts`  | 上传文件         |
| `gets`  | 下载文件         |
| `rm`    | 删除文件         |
| `mkdir` | 创建目录         |
| `rmdir` | 删除目录         |
| `quit`  | 退出客户端        |

网盘项目需要管理不同用户的文件，因此不同用户的文件需要存储在不同的目录中。为了实现这个目的，我们在 `$HOME` 目录中创建一个 `netdisk` 目录。在 `$HOME/netdisk` 目录中 **为每个用户建立一个与用户名相同的目录** 。假设存在两个用户 `dyp` 和 `mike`，那在 `$HOME/netdisk` 中就会存在两个目录

```shell
➜  ~ tree netdisk
netdisk
├── dyp      # 存储 dyp 用户的文件
└── mike     # 存储 mike 用户的文件

3 directories, 0 files
```

用户通过客户端登陆网盘服务器之后，客户端就会展示该用户的根目录 `/`

> [!tip] 
> 
> 也就是说，客户端展示的目录 `/` 代表了服务端的 `$HOME/netdisk/用户名`
> 

## 客户端的职责

客户端需要完成 **连接服务端**、**接受用户输入**、**解析指令**。

### 连接服务端

客户端与服务的建立连接需要执行：**构建地址结构** 和 **调用 `connect()` 系统调用**。我们将这两部封装为一个函数 `tcp_connect()`

```c title:inclue/tcp.h
#ifndef TCP_H
#define TCP_H
#include <sys/socket.h>
#include <netdb.h>

/**
 * @brief Establish a connection with the server
 * 
 * @param hostname Host name of server
 * @param service  Port number of the server
 * @return int    On success, return the socket file descriptor, otherwise -1
 */
int tcp_connect(const char *hostname, const char *service);

#endif  // TCP_H
```

```c title:src/tcp.c
// 库/系统调用的头文件
#include <stddef.h>
#include <unistd.h>

// 自定义头文件
#include <tcp.h>

int tcp_connect(const char *hostname, const char *service) {
    if(hostname == NULL || service == NULL) {
        // 输出日志
        return -1;
    }

    struct addrinfo hints = {
        .ai_flags = AI_NUMERICHOST | AI_NUMERICSERV,
        .ai_family = AF_INET,
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = 0,
    };

    struct addrinfo *res;

    // 解析地址
    if(getaddrinfo(hostname, service, &hints, &res) != 0) {
        // 输出日志
        return -1;
    }

    // 创建套接字
    int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if(sockfd == -1) {
        // 输出日志
        freeaddrinfo(res);
        return -1;
    }
    
    // 建立连接
    if(connect(sockfd, res->ai_addr, res->ai_addrlen) == -1) {
        // 输出日志
        close(sockfd);
        freeaddrinfo(res);
        return -1;
    }
    // 释放 addrinfo 结构
    freeaddrinfo(res);
    return sockfd;
}
```

将 `tcp_connect()` 接入到客户端主程序中

```c title:main.c
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <unistd.h>

#include <tcp.h>

#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"

int main(int argc, char *argv[]) {
    if(argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)) {
        printf("Usage: %s <hostname> <service>\n", argv[0]);
        printf("        - hostname: Host name of server\n");
        printf("        - service: Port number of the server\n");
        printf("Example: %s %s %s\n", argv[0], HOSTNAME, SERVICE);
        return 0;
    }

    const char *hostname = argc > 1 ? argv[1] : HOSTNAME;
    const char *service = argc > 2 ? argv[2] : SERVICE;

    // 与服务端建立连接
    int sockfd = tcp_connect(hostname, service);
    if(sockfd == -1) {
        // 连接失败
        return -1;
    }
    // ...
}
```

### 接受用户的输入

客户端每次只会响应一个命令，在命令执行过程中，我们不希望在命令执行过程中通过 `Ctrl + C (SIGINT )` 和 `Ctrl + \ (SIGQUT)`  直接终止客户端，而是要等待所有命令执行完成后才终止。现在，我们只是简单忽略这两个信号，等客户端功能完成后才设计退出流程

```c title:main.c hl:16-19
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <unistd.h>
#include <signal.h>

#include <tcp.h>

#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"

int main(int argc, char *argv[]) {

    // 忽略 SIGINT 信号
    signal(SIGINT, SIG_IGN);
    // 忽略 SIGQUIT 信号
    signal(SIGQUIT, SIG_IGN);

    if(argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)) {
        printf("Usage: %s <hostname> <service>\n", argv[0]);
        printf("        - hostname: Host name of server\n");
        printf("        - service: Port number of the server\n");
        printf("Example: %s %s %s\n", argv[0], HOSTNAME, SERVICE);
        return 0;
    }

    const char *hostname = argc > 1 ? argv[1] : HOSTNAME;
    const char *service = argc > 2 ? argv[2] : SERVICE;

    // 与服务端建立连接
    int sockfd = tcp_connect(hostname, service);
    if(sockfd == -1) {
        // 连接失败
        perror("tcp_connect");
        return -1;
    }
    // ...
}
```

下面处理客户端如何输入命令的

```c title:inclue/cmd.h
#ifndef CMD_H
#define CMD_H

#include <stdio.h>

/**
 * @brief Read command from standard input
 * 
 * @param buf A buffer for storing commands.
 * @param size The size of the buffer.
 * @param prompt The prompt message.
 * @return int on success, return number of characters read. On error, return -1.
 */
int cmd_read(char * restrict buf, size_t size, const char * restrict prompt);

#endif // CMD_H
```

```c title:src/cmd.c
#include <cmd.h>

int cmd_read(char * restrict buf, size_t size, const char * restrict prompt) {
    printf("%s", prompt);
    size_t len = 0;
    while (len < size - 1 && (buf[len] = getchar()) != '\n') {
        len++;
    }
    buf[len] = '\0';
    return len > 0 ? len : -1;
}
```

### 解析指令

在客户端中，我们按照下面的方式输入指令

```shell
cmd [options] [args]
```

> [!tip]
> 
> `cmd` 这是需要执行的命令
> 
> 命令可能需要选项开启额外的功能。选项按照 Linux shell 选项提供
> 
> 命令还可能需要参数
> 

客户端需要从命令字符串中将 **命令本身**、**命令选项** 以及 **命令参数** 提取出来。根据命令调用对应的函数与服务端进行通信

```c title:include/cmd.h
#ifndef CMD_H
#define CMD_H

#include <stdio.h>

/**
 * @brief Parse command into arguments
 * 
 * @param cmd The command string, eg. "ls -l -a" 
 * @return char** A pointer to an array, which contains a pointer to each argument. For failed, return NULL.
 */
char ** cmd_parse(const char *cmd);


/**
 * @brief execute command, which is generated by cmd_parse.
 * 
 * @param args An array of arguments, which is generated by cmd_parse.
 */
void cmd_exec(char **args);

/**
 * @brief free the memory of arguments, which is generated by cmd_parse.
 * 
 * @param args An array of arguments, which is generated by cmd_parse.
 */
void cmd_free(char **args);
#endif // CMD_H
```

```c title:src/cmd.h
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include <cmd.h>

char ** cmd_parse(const char *cmd) {

    // 跳过前导空白字符串
    while(isspace(*cmd)) {
        cmd++;
    }
    // 计算参数个数
    int argc = 0;

    int i = 0;
    while (cmd[i] != '\0')
    {
        // 跳过非空白字符
        while(!isspace(cmd[i]) && cmd[i] != '\0') {
            i++;
        }
        // 参数个数 +1
        argc++;
        // 跳过当前空白字符
        while(isspace(cmd[i]) && cmd[i] != '\0') {
            i++;
        }
    }
    // printf("argc = %d\n", argc);
    // 分配参数数组
    char **argv = (char **)malloc((argc + 1) * sizeof(char *));
    if(argv == NULL) {
        return NULL;
    }
    
    // 解析参数
    argc = 0;
    const char *star = cmd;
    while (*cmd)
    {
        // 跳过前导非空白字符
        while (!isspace(*cmd) && *cmd != '\0') {
            cmd++;
        }
        // 分配存储参数的内存空间
        argv[argc] = (char *)malloc((cmd - star + 1) * sizeof(char));
        // 分配失败
        if(argv[argc] == NULL) {
            // 释放之前分配的内存
            for(int j = 0; j < argc; j++) {
                free(argv[j]);
            }
            free(argv);
            return NULL;
        }
        // 复制参数
        strncpy(argv[argc], star, cmd - star);
        argv[argc][cmd - star] = '\0';
        // 参数个数 +1
        argc++;
        // 跳过当前空白字符
        while(isspace(*cmd) && *cmd != '\0') {
            cmd++;
        }
        // 记录下一个参数的起始位置
        star = cmd;
    }
    argv[argc] = NULL;
    return argv;
}


void cmd_exec(char **args) {
    for(char **p = args; *p != NULL; p++) {
        printf("%s\n", *p);
    }
}

void cmd_free(char **args) {
    for(char **p = args; *p != NULL; p++) {
        free(*p);
    }
    free(args);
}
```

> [!tip] 
> 
> 由于尚未实现服务端，这里 `cmd_exec()` 仅仅用作占位
> 

### 发送指令给服务端，并等待服务端响应

现在，我们实现 `cmd_exec()` 

```c title:include/cmd.h hl:23,34
#ifndef CMD_H
#define CMD_H

#include <stdio.h>

/**
 * @brief Read command from standard input
 * 
 * @param buf A buffer for storing commands.
 * @param size The size of the buffer.
 * @param prompt The prompt message.
 * @return int on success, return number of characters read. On error, return -1.
 */
int cmd_read(char * restrict buf, size_t size, const char * restrict prompt);

/**
 * @brief Parse command into arguments
 * 
 * @param cmd The command string, eg. "ls -l -a" 
 * @param argc The number of arguments.
 * @return char** A pointer to an array, which contains a pointer to each argument. For failed, return NULL.
 */
char ** cmd_parse(const char *cmd, int *argc);


/**
 * @brief check and execute command, which is generated by cmd_parse
 * 
 * @param fd The file descriptor of the socket.
 * @param args An array of arguments, which is generated by cmd_parse.
 * @param argc The number of arguments.
 * @return int On success, return 0. On error, return -1.
 */
int cmd_exec(int fd, char **args, int argc);

/**
 * @brief free the memory of arguments, which is generated by cmd_parse.
 * 
 * @param args An array of arguments, which is generated by cmd_parse.
 */
void cmd_free(char **args);

#endif // CMD_H
```

> [!tip] 
> 
> 这里，我们修改了 `cmd_parse()` 和 `cmd_exec()` 的接口 
> 

```c title:src/cmd.c
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/uio.h>
#include <sys/socket.h>

#include "cmd.h"

char ** cmd_parse(const char *cmd, int *argc) {
    if(cmd == NULL || argc == NULL) {
        return NULL;
    }

    // 跳过前导空白字符串
    while(isspace(*cmd)) {
        cmd++;
    }

    // 计算参数个数
    *argc = 0;

    int i = 0;
    while (cmd[i] != '\0')
    {
        // 跳过非空白字符
        while(!isspace(cmd[i]) && cmd[i] != '\0') {
            i++;
        }
        // 参数个数 +1
        argc++;
        // 跳过当前空白字符
        while(isspace(cmd[i]) && cmd[i] != '\0') {
            i++;
        }
    }
    // printf("argc = %d\n", *argc);
    // 分配参数数组：参数个数 + 1，最后一个参数为 NULL
    char **argv = (char **)malloc((*argc + 1) * sizeof(char *));
    if(argv == NULL) {
        return NULL;
    }
    
    // 解析参数
    int i = 0;
    const char *star = cmd;
    while (*cmd)
    {
        // 跳过前导非空白字符
        while (!isspace(*cmd) && *cmd != '\0') {
            cmd++;
        }
        // 分配存储参数的内存空间
        argv[i] = (char *)malloc((cmd - star + 1) * sizeof(char));
        // 分配失败
        if(argv[i] == NULL) {
            // 释放之前分配的内存
            for(int j = 0; j < argc; j++) {
                free(argv[j]);
            }
            free(argv);
            return NULL;
        }
        // 复制参数
        strncpy(argv[i], star, cmd - star);
        argv[i][cmd - star] = '\0';
        // 参数个数 +1
        i++;
        // 跳过当前空白字符
        while(isspace(*cmd) && *cmd != '\0') {
            cmd++;
        }
        // 记录下一个参数的起始位置
        star = cmd;
    }
    argv[i] = NULL;
    return argv;
}


static bool is_valid_cmd(const char *cmd) {
    if(cmd == NULL) {
        return false;
    }
    if(strcmp(cmd, "ls") == 0) {
        return true;
    }
    if(strcmp(cmd, "cd") == 0) {
        return true;
    }
    if(strcmp(cmd, "pwd") == 0) {
        return true;
    }
    if(strcmp(cmd, "gets") == 0) {
        return true;
    }
    if(strcmp(cmd, "puts") == 0) {
        return true;
    }
    if(strcmp(cmd, "remove") == 0) {
        return true;
    }
    if(strcmp(cmd, "mkdir") == 0) {
        return true;
    }
    if(strcmp(cmd, "rmdir") == 0) {
        return true;
    }
    return false;
}

static int send_cmd(int fd, struct iovec *iov, int iovcnt) {
    struct msghdr msg;
    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = iov;
    msg.msg_iovlen = iovcnt;
    return sendmsg(fd, &msg, 0);
}

int cmd_exec(int fd, char **args, int argc){
    if(args == NULL) {
        return -1;
    }

    //检查命令是否符合要求
    if(!is_valid_cmd(args[0])) {
        printf("Invalid command: %s\n", args[0]);
        return -1;
    }

    // 计算每个参数的长度
    int argLenVec[argc];
    for(int i = 0; i < argc; i++) {
        argLenVec[i] = strlen(args[i]);
    }

    // 将每次参数的长度发送给服务端
    if(send(fd, argLenVec, sizeof(argLenVec), 0) != sizeof(argLenVec)) {
        perror("send");
        return -1;
    }
    // 构造 iovec
    struct iovec iov[argc];
    for(int i = 0; i < argc; i++) {
        iov[i].iov_base = args[i];
        iov[i].iov_len = argLenVec[i];
    }
    // 将命令发送给服务端：使用分散写 sendmsg
    if(send_cmd(fd, iov, argc) == -1) {
        perror("send_cmd");
        return -1;
    }
    // 根据命令执行不同的操作
    if(strcmp(args[0], "ls") == 0) {
        // TODO 展示文件列表
    } else if(strcmp(args[0], "cd") == 0) {
        // TODO 切换目录
    } else if(strcmp(args[0], "pwd") == 0) {
        // TODO 显示当前目录
    } else if(strcmp(args[0], "gets") == 0) {
        // TODO 下载文件
    } else if(strcmp(args[0], "puts") == 0) {
        // TODO 上传文件
    } else if(strcmp(args[0], "remove") == 0) {
        // TODO 删除文件
    } else if(strcmp(args[0], "mkdir") == 0) {
        // TODO 创建目录
    } else if(strcmp(args[0], "rmdir") == 0) {
        // TODO 删除目录
    }
}
```

## 服务端职责

服务端需要同时响应多个客户端的连接和命令。我们在 [[服务器设计]] 中介绍了几种服务器设计方式，这里我们采用 **事件驱动+线程池** 的服务器结构。这个结构就是在 [[线程池]] 中实现的

### 读取配置信息

针对该项目的服务端，目前我们需要配置 **IP地址** **端口号** **文件存储的根目录**。到后期如果接入数据库，还需要配置数据库的选项等。考虑到配置复杂，我们使用 [toml](https://toml.io/cn/) 文件管理配置，使用 [tomlc99](https://github.com/cktan/tomlc99) 库读取 `toml` 配置文件。要使用  [tomlc99](https://github.com/cktan/tomlc99)库需要先安装

```shell
# 下载 toml-c 源码
git@github.com:cktan/tomlc99.git
cd tomlc99
# 编译
make
# 安装
sudo make install
```

> [!tip] 
> 
> 正常情况下，简单地将 `toml.c` 和 `toml.h` 文件包含在项目中即可
> 

```c title:include/config.h
#ifndef CONFIG_H
#define CONFIG_H

#include <sys/sysinfo.h>

#include <toml.h>

#define HOSTNAME "127.0.0.1"
#define SERVICE "8080"
#define WORKER_NUMBER (2 * get_nprocs_conf())

enum cfgtype {
    CFG_SERVER,
};

struct config {
    unsigned char _pad[1024];
};

struct server_config {
    char *hostname;
    char *service;
    long worker_number;
};


/**
 * @brief Load config from file, and parse it into a struct
 * 
 * @param path where the config file is located
 * @param config the struct to store the config
 * @return int 0 if success, -1 if failed
 */
int load_config(const char *path, struct config *config, enum cfgtype cfgtype);

#endif // CONFIG_H
```

```c title:src/config.c
#include <string.h>
#include <stdlib.h>

#include <config.h>


int load_config(const char *path, struct config *config, enum cfgtype cfgtype) {
    FILE *file = fopen(path, "r");
    if(file == NULL) {
        fprintf(stderr, "Failed to open config file: %s\n", path);
        return 1;
    }

    char errbuf[200];
    
    toml_table_t *toml = toml_parse_file(file,errbuf, sizeof(errbuf));
    fclose(file);

    if(config == NULL) {
        fprintf(stderr, "Failed to parse config file: %s\n", path);
        return 1;
    }

    switch (cfgtype)
    {
    case CFG_SERVER:
        // 获取 [server] 下的配置
        toml_table_t *server = toml_table_in(toml, "server");
        if(server == NULL) {
            fprintf(stderr, "Failed to get [server] section\n");
            return -1;
        }
        // 获取 hostname
        toml_datum_t hostname = toml_string_in(server, "hostname");
        if(hostname.ok) {
            strncpy(
                ((struct server_config *)config)->hostname,
                strlen(hostname.u.s) ? hostname.u.s: HOSTNAME, 
                16
            );
            free(hostname.u.s);
        } else {
            strncpy(
                ((struct server_config *)config)->hostname, 
                HOSTNAME, 
                16
            );
        }

        // 获取 service
        toml_datum_t service = toml_string_in(server, "service");
        if(service.ok) {
            strncpy(
                ((struct server_config *)config)->service, 
                strlen(service.u.s) ? service.u.s:SERVICE, 
                6
            );
            free(service.u.s);
        } else {
            strncpy(
                ((struct server_config *)config)->service,
                SERVICE,
                6
            );
        }
        // 获取 worker_number
        toml_datum_t worker_number = toml_int_in(server, "worker_number");
        if(worker_number.ok) {
            ((struct server_config *)config)->worker_number = worker_number.u.i ? worker_number.u.i : WORKER_NUMBER;
        } else {
            ((struct server_config *)config)->worker_number = WORKER_NUMBER;
        }
        break;
    default:
        fprintf(stderr, "Unknown config type\n");
        return -1;
        break;
    }

    return 0;
}
```

### 创建监听套接字

服务端需要创建一个 SOCKET 文件，并使用本机连接外网的网卡绑定的 IP 地址和一个端口号绑定。这样，服务端就能通过网络访问了。

这个过程比较复杂，我们将其封装在 `tcp_listen()` 函数中

```c title:include/tcp.h
#ifndef TCP_H
#define TCP_H

#include <sys/types.h>
#include <sys/socket.h>
#undef __USE_XOPEN2K
#define __USE_XOPEN2K
#include <netdb.h>


/**
 * @brief Create a TCP/IPv4 socket and bind it to the given hostname and service
 * 
 * @param hostname The hostname, which can be an IP address or a domain name
 * @param service The service, which can be a port number or a service name
 * @return int on success, the file descriptor of the socket; on failure, -1
 */
int tcp_listen(const char *hostname, const char *service);

#endif // TCP_H
```

```c title:src/tcp.c
#include <unistd.h>

#include "tcp.h"

int tcp_listen(const char *hostname, const char *service) {
    
    struct addrinfo hints = {
        .ai_flags = AI_PASSIVE | AI_NUMERICHOST | AI_NUMERICSERV,
        .ai_family = AF_INET,
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = 0
    };    

    struct addrinfo *res;

    if(getaddrinfo(hostname, service, &hints, &res) != 0) {
        return -1;
    }

    int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if(sockfd == -1) {
        freeaddrinfo(res);
        return -1;
    }

    if(bind(sockfd, res->ai_addr, res->ai_addrlen) == -1) {
        freeaddrinfo(res);
        close(sockfd);
        return -1;
    }

    if(listen(sockfd, SOMAXCONN) == -1) {
        freeaddrinfo(res);
        close(sockfd);
        return -1;
    }

    freeaddrinfo(res);
    return sockfd;
}
```

将 `tcp_listen()` 接入服务端

```c title:main.c hl:32-36
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/sysinfo.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include "config.h"
#include "tcp.h"

#define CONFIG_PATH "config/config.toml"


int main(int argc, char *argv[]) {

    if(argc > 1 && strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <config file>\n", argv[0]);
        return 1;
    }

    char *config_path = argc > 2 ? argv[1] : CONFIG_PATH;

    struct server_config server_config;
    server_config.hostname = malloc(sizeof(char) * 16);
    server_config.service = malloc(sizeof(char) * 6); 
    if(load_config(config_path, (struct config *)&server_config, CFG_SERVER) != 0) {
        fprintf(stderr, "Failed to load config\n");
        return 1;
    }

    int sockfd = tcp_listen(server_config.hostname, server_config.service);
    if(sockfd == -1) {
        fprintf(stderr, "Failed to create socket\n");
        return 1;
    }
    
    return 0;
}
```

### 事件驱动

服务端需要处理多个客户端的连接和客户端的命令。我们使用 `epoll` 监控 `sockefd` 和 每个 `netfd`，没得它们准备就绪后就完成。当客户端关闭连接，或者超时未发送命令就应该剔除

添加 `fd` 到 `epoll` 实例和从 `epoll` 实例中删除 `fd` 的操作较为复杂，这里我们将其封装为 `epoll_add()` 和 `epoll_del()` 两个函数

```c title:include/epoll.h
#ifndef EPOLL_H
#define EPOLL_H
#include <sys/types.h>
#include <sys/epoll.h>

/**
 * @brief Add fd to the epoll instance to listen for events events
 * 
 * @param epfd File descriptor for the epoll instance
 * @param fd  The file descriptor to add
 * @param events Events to listen fo
 * @return on success return 0, otherwise return -1
 */
int epoll_add(int epfd, int fd, uint32_t events);

/**
 * @brief delete fd from the epoll instance
 * 
 * @param epfd File descriptor for the epoll instance
 * @param fd The file descriptor to delete
 * @return on success return 0, otherwise return -1
 */
int epoll_del(int epfd, int fd);
#endif
```

```c title:src/epoll.c
/* 封装 epoll_ctl */

#include <stddef.h>
#include "epoll.h"


int epoll_add(int epfd, int fd, uint32_t events) {
    struct epoll_event ev;
    ev.events = events;
    ev.data.fd = fd;
    if(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) == -1) {
        return -1;
    }
    return 0;
}

int epoll_del(int epfd, int fd) {
    if(epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL) == -1) {
        return -1;
    }
    return 0;
}
```

将 `epoll_add()` 接入服务端

```c title:main.c hl:45-95
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <sys/sysinfo.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include "config.h"
#include "tcp.h"
#include "epoll.h"

#define CONFIG_PATH "config/config.toml"

int main(int argc, char *argv[]) {

    if(argc > 1 && strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <config file>\n", argv[0]);
        return 1;
    }

    char *config_path = argc > 2 ? argv[1] : CONFIG_PATH;

    // 读取服务端配置文件
    struct server_config server_config;
    server_config.hostname = malloc(sizeof(char) * 16);
    server_config.service = malloc(sizeof(char) * 6); 
    if(load_config(config_path, (struct config *)&server_config, CFG_SERVER) != 0) {
        fprintf(stderr, "Failed to load config\n");
        return 1;
    }

    // 创建线程池


    // 创建监听套接字
    int sockfd = tcp_listen(server_config.hostname, server_config.service);
    if(sockfd == -1) {
        fprintf(stderr, "Failed to create socket\n");
        return 1;
    }

    // 创建 epoll 实例
    int epfd = epoll_create(1024);
    if(epfd == -1) {
        fprintf(stderr, "Failed to create epoll\n");
        return 1;
    }

    // 添加监听套接字到 epoll 实例
    if(epoll_add(epfd, sockfd, EPOLLIN) == -1) {
        fprintf(stderr, "Failed to add sockfd to epoll\n");
        return 1;
    }

    // 监控文件描述符个数
    int monitorNumber = 1;
    // 就像数组大小
    int readySize = 2 * monitorNumber;
    // 创建就绪时间数组
    struct epoll_event *events = malloc(sizeof(struct epoll_event) * readySize);

    while (true)
    {
        int readyNumber = epoll_wait(epfd, events, 2 * monitorNumber, -1);
        if(readyNumber == -1) {
            fprintf(stderr, "Failed to wait for epoll\n");
            return 1;
        }

        // 循环处理事件
        for(int i = 0; i < readyNumber; i++) {
            if(events[i].data.fd == sockfd) {
                // 有新的客户端连接
                int netfd = accept(events[i].data.fd, NULL, NULL);
                if(netfd == -1) {
                    fprintf(stderr, "Failed to accept\n");
                    return 1;
                }
                // 添加新的客户端连接到 epoll 实例
                if(epoll_add(epfd, netfd, EPOLLIN) == -1) {
                    fprintf(stderr, "Failed to add netfd to epoll\n");
                    return 1;
                }
                monitorNumber++;
                if(monitorNumber > readySize) {
                    readySize = 2 * monitorNumber;
                    events = realloc(events, sizeof(struct epoll_event) * readySize);
                    if(events == NULL) {
                        fprintf(stderr, "Failed to realloc events\n");
                        return 1;
                    }
                }
            } else {
                // 客户端发来命令
            }
        }
    }

    return 0;
}

```

### 创建任务队列

服务端读取客户端发送过来的命令，然后将其打包成为为一个任务并放入任务队列中。通过 **互斥锁 + 条件变量** 的方式实现保护任务队列的并发安全

```c title:include/task.h
#ifndef TASK_H
#define TASK_H

#include <pthread.h>
#include <stdint.h>

#define MAX_TASK_QUEUE_SIZE 1024

typedef struct task task_t;

/**
 * @brief task handler function
 * 
 * @param fd the file descriptor of the network communication
 * @return on success, return 0; on error, return -1
 */
typedef int(*task_handler_t)(int fd);

/**
 * @brief task queue structure
 * 
 * + head: the head of the task queue
 * 
 * + tail: the tail of the task queue
 * 
 * + mutex: the mutex lock for the task queue
 * 
 * + cond: the condition variable for the task queue
 * 
 */
typedef struct task_queue {
    task_t *head;      // 任务队列的头
    task_t *tail;      // 任务队列的尾
    uint64_t size;       // 任务队列的大小
    pthread_mutex_t mutex;  // 互斥锁
    pthread_cond_t cond;    // 条件变量
} task_queue_t;

struct task {
    int fd;                 // 网络通信的文件描述符
    task_handler_t handler; // 任务处理函数
    task_t *next;           // 下一个任务
};

/**
 * @brief initiate a empty task queue
 * 
 * @param queue the task queue to be initiated
 * @return on success, return 0; on error, return -1
 */
int task_queue_init(task_queue_t * queue);

/**
 * @brief add a task to the task queue
 * 
 * @param queue the task queue, where the task will be added
 * @param fd the file descriptor of the network communication
 * @param handler the task handler function
 * @return on success, return 0; on error, return -1
 */
int task_queue_push(task_queue_t * queue, int fd, task_handler_t handler);

/**
 * @brief pop a task from the task queue
 * 
 * @param queue the task queue, where the task will be popped
 * @param t the task to be popped
 * @return on success, return 0; on error, return -1
 */
int task_queue_pop(task_queue_t * queue, task_t * t);

/**
 * @brief Destroy task queue
 * 
 * @param queue the task queue to be destroyed
 * @return on success, return 0; on error, return -1
 */
int task_queue_destroy(task_queue_t * queue);

#endif // TASK_H
```

> [!tip] 
> 
> `task_handler_t` 是任务处理函数，该函数供线程函数调用
> 

```c title:src/task.c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "task.h"

/**
 * @brief create a task, and return the pointer to the task
 * 
 * @param fd the file descriptor of the network communication
 * @param argc the number of arguments
 * @param argv the arguments. argv[0] is the command, and the others are the arguments
 * @param handler the task handler function
 * @return task_t* the pointer to the task，on error, return NULL
 */
static task_t * task_create(int fd, int argc, char *argv[], task_handler_t handler);

/**
 * @brief destroy a task
 * 
 * @param t the task to be destroyed
 */
static void task_destroy(task_t * t);


int task_queue_init(task_queue_t * queue) {
    if(queue == NULL) {
        return -1;
    }
    queue->head = NULL;
    queue->tail = NULL;
    queue->size = 0;
    // 初始化互斥锁
    if(pthread_mutex_init(&queue->mutex, NULL) != 0) {
        return -1;
    }
    // 初始化条件变量
    if(pthread_cond_init(&queue->cond, NULL) != 0) {
        return -1;
    }
    return 0;
}

int task_queue_push(task_queue_t * queue, int fd, int argc, char *argv[], task_handler_t handler) {
    if(queue == NULL) {
        return -1;
    }
    task_t *t = task_create(fd, argc, argv, handler);
    if(t == NULL) {
        return -1;
    }

    // 加锁: 保护队列的操作
    if(pthread_mutex_lock(&queue->mutex) != 0) {
        return -1;
    }

    // 队列满了，等待子线程处理任务
    while (queue->size == MAX_TASK_QUEUE_SIZE)
    {
        // 等待条件变量发生变化
        if(pthread_cond_wait(&queue->cond, &queue->mutex) != 0) {
            return -1;
        }
    }
    
    if(queue->head == NULL) {
        queue->head = t;
        queue->tail = t;
    } else {
        queue->tail->next = t;
        queue->tail = t;
    }
    queue->size++;

    // 解锁：释放锁
    if(pthread_mutex_unlock(&queue->mutex) != 0) {
        return -1;
    }

    // 通知等待的线程条件变量发生变化
    if(pthread_cond_signal(&queue->cond) != 0) {
        return -1;
    }
    
    return 0;
}

int task_queue_pop(task_queue_t * queue, task_t * t) {
    if(queue == NULL || t == NULL) {
        return -1;
    }
    // 加锁: 保护队列的操作
    if(pthread_mutex_lock(&queue->mutex) != 0) {
        return -1;
    }
    // 队列为空，等待主线程将任务添加到队列
    while (queue->size == 0) 
    {
        // 等待条件变量发生变化
        if(pthread_cond_wait(&queue->cond, &queue->mutex) != 0) {
            return -1;
        }
    }
    // 从队列中取出任务
    *t = *(queue->head);
    
    // 释放队列中被取出的任务
    task_t *tmp = queue->head;
    queue->head = queue->head->next;
    
    task_destroy(tmp);
    queue->size--;
    
    // 队列为空
    if(queue->size == 0) {
        queue->tail = NULL;
    }
    // 解锁：释放锁
    if(pthread_mutex_unlock(&queue->mutex) != 0) {
        return -1;
    }
    // 通知主线程条件变量发生变化
    if(pthread_cond_signal(&queue->cond) != 0) {
        return -1;
    }
    return 0;
}

int task_queue_destroy(task_queue_t * queue) {
    if (queue == NULL) {
        return -1;
    }
    // 释放任务队列中的未被执行的任务任务
    while (queue->head != NULL)
    {
        task_t *tmp = queue->head;
        // 关闭文件描述符
        close(tmp->fd);
        queue->head = queue->head->next;
        // 释放任务
        task_destroy(tmp);
    }

    // 销毁互斥锁
    if(pthread_mutex_destroy(&queue->mutex) != 0) {
        return -1;
    }
    // 销毁条件变量
    if(pthread_cond_destroy(&queue->cond) != 0) {
        return -1;
    }
    return 0;
}


task_t * task_create(int fd, int argc, char *argv[], task_handler_t handler) {
    task_t *t = (task_t *)malloc(sizeof(task_t));
    if(t == NULL) {
        return NULL;
    }
    t->fd = fd;
    t->argc = argc;

    // 为参数列表分配内存
    t->argv = (char **)malloc(sizeof(char *) * argc + 1);
    if(t->argv == NULL) {
        free(t);
        return NULL;
    }
    memcpy(t->argv, argv, sizeof(char *) * argc + 1);
    t->handler = handler;
    t->next = NULL;
    return t;
}

void task_destroy(task_t * t) {
    if(t == NULL) {
        return;
    }
    // 释放参数列表
    free(t->argv);
    // 释放任务
    free(t);
}
```

### 创建线程池

线程池中的所有线程均从任务队列中读取任务，并调用任务处理函数

```c title:include/pool.h
#ifndef POOL_H
#define POOL_H

#include <pthread.h>
#include "task.h"

#define EXIT_TASK_FD -1

typedef struct thread_pool {
    int num_threads;
    pthread_t *threads;
} thread_pool_t;

/**
 * @brief Initialize a thread pool
 * 
 * @param pool pointer to the thread pool, must be allocated, which will be initialized
 * @param num_threads number of threads to create
 * @param queue pointer to the task queue, which will be used by the threads
 * @return on success, return 0, otherwise return -1
 */
int thread_pool_init(thread_pool_t *pool, int num_threads, task_queue_t *queue);

/**
 * @brief Destroy a thread pool
 * 
 * @param pool pointer to the thread pool to destroy, which will be destroyed
 * @return on success, return 0, otherwise return -1
 */
int thread_pool_destroy(thread_pool_t *pool);
#endif
```

```c title:src/pool.c
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>

#include "pool.h"


static void *routine(void *arg) {
    fprintf(stdout, "Thread[TID %#lx] is starting, who is waiting for task\n", (long int)pthread_self());
    task_queue_t *queue = (task_queue_t *)arg;
    while(true) {
        task_t task;
        if(task_queue_pop(queue, &task) == -1) {
            // get task error
            fprintf(stderr, "get task error\n");
            continue;
        }
        fprintf(stdout, "Thread[TID %#lx] is handling task for fd: %d\n", (long int)pthread_self(), task.fd);
        if(task.handler(task.fd) == -1) {
            // handle error
            fprintf(stderr, "handle error for fd: %d\n", task.fd);
            continue;
        }
        fprintf(stdout, "Thread[TID %#lx] has handled task for fd: %d\n", (long int)pthread_self(), task.fd);
    }
    return NULL;
}

int thread_pool_init(thread_pool_t *pool, int num_threads, task_queue_t *queue) {
    if(pool == NULL) {
        return -1;
    }

    pool->num_threads = num_threads;
    pool->threads = (pthread_t *)malloc(num_threads * sizeof(pthread_t));
    if(pool->threads == NULL) {
        return -1;
    }
    // 创建线程
    for(int i =0; i < num_threads; i++) {
        if(pthread_create(&pool->threads[i], NULL, routine, queue) != 0) {
            return -1;
        }
    }
    return 0;
}

int thread_pool_destroy(thread_pool_t *pool) {
    if(pool == NULL) {
        return -1;
    }
    free(pool->threads);
    return 0;
}
```

> [!tip] 
> 
> 函数 `routine()` 是线程函数，该函数任务队列中读取任务
> 

将线程池接入服务端

```c title:main.c hl:37-49
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <sys/sysinfo.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include "config.h"
#include "tcp.h"
#include "epoll.h"
#include "pool.h"


#define CONFIG_PATH "config/config.toml"


int main(int argc, char *argv[]) {

    if(argc > 1 && strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <config file>\n", argv[0]);
        return 1;
    }

    char *config_path = argc > 2 ? argv[1] : CONFIG_PATH;

    // 读取服务端配置文件
    struct server_config server_config;
    server_config.hostname = malloc(sizeof(char) * 16);
    server_config.service = malloc(sizeof(char) * 6); 
    if(load_config(config_path, (struct config *)&server_config, CFG_SERVER) != 0) {
        fprintf(stderr, "Failed to load config\n");
        return 1;
    }

    // 创建任务队列
    task_queue_t task_queue;
    if(task_queue_init(&task_queue) != 0) {
        fprintf(stderr, "Failed to create task queue\n");
        return 1;
    }

    // 创建线程池
    thread_pool_t pool;
    if(thread_pool_init(&pool, server_config.worker_number, &task_queue) != 0) {
        fprintf(stderr, "Failed to create thread pool\n");
        return 1;
    }

    // 创建监听套接字
    int sockfd = tcp_listen(server_config.hostname, server_config.service);
    if(sockfd == -1) {
        fprintf(stderr, "Failed to create socket\n");
        return 1;
    }

    // 创建 epoll 实例
    int epfd = epoll_create(1024);
    if(epfd == -1) {
        fprintf(stderr, "Failed to create epoll\n");
        return 1;
    }

    // 添加监听套接字到 epoll 实例
    if(epoll_add(epfd, sockfd, EPOLLIN) == -1) {
        fprintf(stderr, "Failed to add sockfd to epoll\n");
        return 1;
    }

    // 监控文件描述符个数
    int monitorNumber = 1;
    // 就像数组大小
    int readySize = 2 * monitorNumber;
    // 创建就绪时间数组
    struct epoll_event *events = malloc(sizeof(struct epoll_event) * readySize);

    while (true)
    {
        int readyNumber = epoll_wait(epfd, events, 2 * monitorNumber, -1);
        if(readyNumber == -1) {
            fprintf(stderr, "Failed to wait for epoll\n");
            return 1;
        }

        // 循环处理事件
        for(int i = 0; i < readyNumber; i++) {
            if(events[i].data.fd == sockfd) {
                // 有新的客户端连接
                int netfd = accept(events[i].data.fd, NULL, NULL);
                if(netfd == -1) {
                    fprintf(stderr, "Failed to accept\n");
                    return 1;
                }
                // 添加新的客户端连接到 epoll 实例
                if(epoll_add(epfd, netfd, EPOLLIN) == -1) {
                    fprintf(stderr, "Failed to add netfd to epoll\n");
                    return 1;
                }
                monitorNumber++;
                if(monitorNumber > readySize) {
                    readySize = 2 * monitorNumber;
                    events = realloc(events, sizeof(struct epoll_event) * readySize);
                    if(events == NULL) {
                        fprintf(stderr, "Failed to realloc events\n");
                        return 1;
                    }
                }
            } else {
                // 客户端发来命令
            }
        }
    }
    
    return 0;
}
```

### 响应客户端命令

服务端需要从 `netfd` 中读取客户端发送过来的命令，然后生成任务，并将其加入任务队列


```c title:include/service.h
#ifndef SERVICE_H
#define SERVICE_H


/**
 * @brief receive command from client
 * 
 * @param fd client socket fd
 * @param args pointer to the command arguments
 * @param argc pointer to the number of arguments
 * @return int 0 on success, -1 on error
 */
int recv_cmd(int fd, char ***args, int *argc);

#endif // SERVICE_H

```

```c title:src/service.c
#include <sys/uio.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>

#include "service.h"

int recv_cmd(int fd, char ***args, int *argc) {
    // 读取 argc
    if(recv(fd, argc, sizeof(int), 0) != sizeof(int)) {
        return -1;
    }
    // 读取每个参数的长度
    int argLenVec[*argc];
    if(recv(fd, argLenVec, sizeof(int) * (*argc), 0) != sizeof(int) * (*argc)) {
        return -1;
    }
    int totalLen = 0;
    for(int i = 0; i < *argc; i++) {
        totalLen += argLenVec[i];
    }
    
    // 为每个参数分配空间
    *args = malloc(sizeof(char *) * (*argc + 1));
    (*args)[*argc] = NULL;
    for(int i = 0; i < *argc; i++) {
        (*args)[i] = malloc(argLenVec[i] + 1);
    }

    // 读取每个参数
    struct iovec iov[*argc];
    for(int i = 0; i < *argc; i++) {
        iov[i].iov_base = (*args)[i];
        iov[i].iov_len = argLenVec[i];
    }
    
    if(recvmsg(fd, &(struct msghdr) { .msg_iov = iov, .msg_iovlen = *argc }, 0) != totalLen) {
        return -1;
    }

    for(int i = 0; i < *argc; i++) {
        (*args)[i][argLenVec[i]] = '\0';
    }
    return 0;
}
```

## 实现命令

### 实现 cd 命令


为了实现 `cd`，我们在 `$HOME` 目录中创建一个 `netdisk` 目录。在 `$HOME/netdisk` 目录中 **为每个用户建立一个与用户名相同的目录** 。假设存在两个用户 `dyp` 和 `mike`，那在 `$HOME/netdisk` 中就会存在两个目录

```shell
➜  ~ tree netdisk
netdisk
├── dyp      # 存储 dyp 用户的文件
└── mike     # 存储 mike 用户的文件

3 directories, 0 files
```

用户通过客户端登陆网盘服务器之后，客户端就会展示该用户的根目录 `/`

> [!tip] 
> 
> 也就是说，客户端展示的目录 `/` 代表了服务端的 `$HOME/netdisk/用户名`
> 



