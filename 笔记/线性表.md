# 线性表

**_数据结构_** 是计算机科学的基础。它们提供了一种 **_组织_** 和 **_存储_** 数据的特定方法，以便可以 _有效地访问和使用数据_

不同类型的数据结构包括 **数组**、**链表**、**栈**、**队列**、**哈希表**、**树** 和 **图** 形。其中每一种都有其独特的特征和使用场景，并且对于某些类型的操作来说是最佳的

> [!tip] 
> 数组非常适合随机访问，而链表则非常适合频繁的插入和删除

正确选择数据结构可以显着提高程序的性能。

> [!important] 数据结构的重要性
> 
>**数据结构提供了一种以高效且可管理的格式组织和存储数据的方法**。它们至关重要，因为它们构成了现代算法设计的基础
>
>为特定任务选择或设计最适合的数据结构，可能取决于功能强大且高效的解决方案与功能不强大的解决方案之间的差异
>
>它们允许以各种方式处理数据--存储、排序、排序或访问--这是软件或数据库开发不可或缺的一部分
>
>通过设计有效的数据结构，程序可以提高性能、简化编码过程、实现数据的灵活性，最重要的是，以显着的方式降低代码的复杂性

现在我们学习第一种数据结构 **线性表**。线性表是数学概念，在实现方式有两种

+ **顺序表** 是静态数据结构， _相同类型的元素存储在连续的内存位置_ 

+ **链表** 是动态数据结构， _元素存储在各个节点中，每个节点都指向下一个_。

## 定义


**线性表**，顾名思义，就是 **具有像线一样的性质的序列**。数学符号的记法如下：线性表记为 $(a_1,a_2,\cdots, a_n)$，则表中 $a_{i-1}$ 领先于 $a_i$，称 $a_{i-1}$ 是 $a_i$ 的 **直接前驱元素**，当然，$a_i$ 领先于 $a_{i+1}$ ，称 $a_{i+1}$ 是 $_{i}$ 的 **直接后继元素**

![[Pasted image 20240930214647.png]]

线性表的元素个数 $n(n \ge 0)$ 称为 **线性表的长度**，当 $n=0$ 是称为 **空表**。在 **非空表中的每个元素都有一个确定的位置**

> [!example] 
> 
> 例如，$1$ 是第一个数据元素，$n$ 是最后一个数据元素，$i$ 是第 $i$ 个数据元素，称 $i$ 为数据元素 $i$ 在线性表中的 **位序**
> 

一年里的星座列表是不是线性表？毫无疑问是的

![[Pasted image 20240930214756.png]]

班级同学的花名册就是线性表。首先，它是有限的序列，类型相同。其次，每个元素除学生学号外还可以有其他的信息。**比较复杂的线性表中，一个 _数据元素_ 可以由若干 _数据项_ 组成**

> [!important] 逻辑结构 与 物理结构
> 
> 线性表是一种 **逻辑结构**。所谓的数据结构都是逻辑结构
> 
> 当线性表中的元素存储在物理内存上时，在内存上存储的结构称为 **物理结构**。有两种常用的物理结构
> + 顺序结构：元素存储在一片连续的内存空间中
> + 链式结构：元素以结点的形式在内存中分散存储，每个结点可以找到它之后的结点

既然是一个表结构，首先需要存储数据，**创建表**（或初始化表）是首先需要执行的操作；需要向表中 **插入** 数据，当数据不需要的时候 **删除**，这两个基本操作是必不可少的。当表中数据到达一定量的时候，发现在表中 **搜索** 数据变得麻烦了，可能需要对表中数据进行 **排序**，搜索和排序必须要知道表的数据长度；数据会时常发生变化，**修改** 数据是不可避免的被需要。当表不被需要时，**销毁表** 是必不可少的操作

综上所述，线性表的抽象数据类型如下

```c
ADT List {
	Data
    	相同数据类型的集合{a_1, a_2, ...., a_n}
   	Relation
    	一对一线性关系
    Operation
    	ListInit(&L): 初始化，创建一个空表L
        IsListEmpty(L): 表 L 是空表返回 true，否则返回 false
        ClearList(L): 清空表 L
        DestroyList(&L): 销毁表 L 释放所有元素
        GetElement(L, i, &e): 将表 L 的第 i 个元素返回给 e
        LocateElement(L, e): 在表 L 中查找元素 e
        					 找到返回 true，否则返回 false
        ListInsert(&L, i, e): 在表 L 的第 i 个位置插入 e
        ListDelete(&L, i, &e): 删除表 L 的第 i 个元素并返回给 e
        ListLength(L): 获取表 L 的元素个数
}
```


线性表可以使用顺序结构实现（称为顺序表），也可以使用链式结构实现（称为链表）

> [!tip] 
> 数组是一种顺表。这里我们就不再多做介绍，详细内容查看 [[数组]]
> 

## 链表

顺序表中，插入和删除都需要找到插入位置和删除的位置，这是无法避免的开销。然而，插入之前需要移动元素，将插入位置空出来；删除之后需要移动元素填充被移出的元素空闲位置。这些开销是不必要的

为了避免插入之前和删除之后移动元素带来的开销，我们允许表的数据元素可以 **不连续存储**，这样就避免插入之前和删除之后带来的元素移动性能损耗。下图是链表的描述

![[Pasted image 20240930215041.png]]

由于数据元素的存储不连续，因此，为了表示每个数据元素 $a_i$ 与其直接后继数据元素 $a_{i+1}$ 之间的逻辑关系。对于数据  $a_i$ 来说，除了存储其 **本身的信息** 外，还需要存储一个 **表示其直接后继的信息**，即 **直接后继的存储位置**

> [!tip] 
> 
> 把存储数据元素信息的域称为 **数据域**
> 
> 存储直接后继位置的域称为 **指针域**
> 

$n$ 个结点链接成一个**链表**，即线性表 $(a_1,a_2,\cdots,a_n)$ 的链式存储结构

![[Pasted image 20240930215136.png]]

对于链表而言，我们需要知道 **第一个元素所在的位置**。只需要记录第一个元素的指针，整个链表的存取就必须从头指针开始，之后的每一个节点就是上一个的的后继指针指向的位置。链表的 **最后一个结点指针为空**，通常用 `NULL` 表示

![[Pasted image 20240930215209.png]]

由于链表将逻辑关系存储为了结点指向其后继元素的指针。因此，我们将链表显示表示为

![[Pasted image 20240930215228.png]]

### 类型声明

因此，这里将涉及两个类型。一个是 **链表本身**，另一个则是链表中的 **结点**。链表作为一个容器，就必须知道 **_起始结点的地址_**；为了方便尾部插入数据，还可以记录 **_最后一个结点的地址_**；容器自身应该知晓其大小，就是容器中 **_元素的个数_**。所以，链表这个结构可以描述为

```c title:list.H
#ifndef LIST_H
#define LIST_H

typedef int ElementType ;
typedef struct node Node; // 不完整类型，C 语言中唯一封装数据的手段
typedef struct list List; 

#endif  // LIST_H
```

在 `.c` 文件定义结构体，隐藏具体实现

```c title:list.c
#include "list.h"

struct node {
    ElementType data;
    struct node *next;
};

struct list {
    Node *head;
    Node *tail;
    int size;
};
```

###  初始化

最开始，链表中没有元素。所以，此时 `head` 和 `tail` 均为 `nullptr`，并且 `size` 为 $0$

首先在 `list.h` 中补充函数原型

```c title:list.h
// 初始化：初始化链表 l
list_t NewList(list_t l);
```

然后，在 `list.c` 中补充函数实现

```c title:list.c
list_t NewList(list_t l){

    if (l == nullptr) {
        l = (list_t) malloc(sizeof(list_t));
    }

    l->head = nullptr;
    l->tail = nullptr;
    l->size = 0;
    return l;
}
```

### 插入

#### 尾部追加

尾部追加元素，这里需要分 空链表和非空链表 两种情形处理

插入时链表为 **空链表**，即 `head == nullptr && tail == nullptr || size == 0`；就是 **_插入第一个结点的情形

![[Pasted image 20241001075640.png]]

插入时如果链表为空，就让 `head` 和 `tail` 都指向第一个结点，并让 `size` 增加 $1$

![[Pasted image 20241001080057.png]]

当 **_插入结点不是第一个结点_** 时，让尾部结点的指针指向新结点，让 `tail` 指向新结点

![[Pasted image 20241001081144.png]]

下面补充 `Append` 函数的实现。首先补充函数原型

```c title:list.h
// 尾部追加  
bool Append(elem_t e, list_t l);
```

> [!tip] 
> 
> 成功插入返回 `true`，失败返回 `false`
> 

然后，补充 `Append` 函数的实现

```c title:list.c
bool Append(elem_t e, list_t l) {

    if (l == nullptr) {
        return false;
    }

    auto node = (node_t) malloc(sizeof(struct node));
    node->value = e;
    node->next = nullptr;

    // 插入第一个节点
    if (l->head == nullptr && l->tail == nullptr) {
        l->head = node;
        l->tail = node;
    } else {
        // 插入的不是第一个节点
        l->tail->next = node;
        l->tail = node;
    }

    l->size++;
    return true;
}
```

#### 指定索引

需要从第一个结点开始遍历，找到指定索引的位置。这里，需要记录前一个结点(`pre`)。当找到插入位置后

> [!tip] 插入操作
> + 首先，让新结点(`new`) 的 `next` 指向当前结点(`cur`)
> + 然后，让`pre` 的 `next` 指向新结点

![[Pasted image 20241001082400.png]]

特殊情况：**插入结点作为新的第一个结点**

> [!tip] 
> + 首先，让新结点(`new`)的 `next` 指向 `head`
> + 然后，让 `head` 指向新结点(`new`)

![[Pasted image 20241001082450.png]]

特殊情况：**插入结点作为新的尾结点**，直接调用 `Append()` 即可

下面补充 `Insert` 函数的实现。首先补充函数原型

```c title:list.h
bool Insert(elem_t e, int pos, list_t l);
```

补充 `Insert` 实现

```c title:list.c
bool Insert(elem_t e, int pos, list_t l) {
    if (l == nullptr) {
        return false;
    }

    node_t node = (node_t) malloc(sizeof(struct node));
    node->value = e;
    node->next = nullptr;


    if (pos <= 0) {
        // 头部插入
        node->next = l->head;
        l->head = node;

    } else if(pos >= l->size) {
        // 尾部插入
        return Append(e, l);
    } else {
        // 遍历插入点

        node_t pre = nullptr;
        node_t cur = l->head;

        int i = 0;

        while (i < pos && cur != nullptr) {
            pre = cur;
            cur = cur->next;
            i++;
        }

        node->next = cur;
        pre->next = node;
    }
    l->size++;
    return true;
}
```

### 遍历


```c
void Iterate(list_t l, void(*traverser)(elem_t e)) {  
    if (l == nullptr) {  
        return;  
    }  
    node_t cur = l->head;  
    printf("[");  
    while (cur != nullptr) {  
        traverser(cur->value);  
        cur = cur->next;  
    }  
    printf("]\n");  
}
```

### 删除

删除元素有两种方式：按元素删除和按索引删除。但是，删除操作却是一样的

![[Pasted image 20241001094209.png]]

#### 按元素删除

需要从头开始遍历，比较每个结点的 `value`，需要记录上一个结点，当找到 `value` 所在的结点，即可直接删除。注意特殊位置：第一个结点需要修改 `head`；最后一个结点需要修改 `tail`

下面补充 `Remove` 函数的实现。首先补充函数原型

```c title:list.h
// 指定元素删除  
bool Remove(elem_t e, list_t l);
```

补充 `Remove` 实现

```c title:list.c
bool Remove(elem_t e, list_t l) {
    if (l == nullptr) {
        return false;
    }
    node_t cur = l->head;
    node_t prev = nullptr;
    // 查找删除节点
    while (cur != nullptr && cur->value != e) {
        prev = cur;
        cur = cur->next;
    }


    if (prev == nullptr) {
        // 删除头节点
        l->head = cur->next;
    } else if (cur == l->tail) {
        // 删除尾结点
        l->tail = prev;
        prev->next = nullptr;
    } else {
	    // 删除节点在中间
        prev->next = cur->next;
    }
    free(cur); // 记得释放内存，避免内存溢出
    l->size--;
    return true;
}
```

#### 按索引删除

需要从第一个结点开始，遍历到索引 `i` 处，需要记录当前遍历结点的前一个结点，用于删除

下面补充 `Pop` 函数的实现。首先补充函数原型

```c title:list.h
// 指定索引删除  
elem_t Pop(int pos, list_t l);
```

补充 `Pop` 实现

```c title:list.c
bool Pop(int pos, list_t l, elem_t *ret) {
    if (l == nullptr) {
        return false;
    }

    if(pos <= 0 || pos >= l->size) {
        // 删除失败，给定索引超出范围
        return false;
    }

    node_t cur = l->head;
    node_t prev = nullptr;
    int i = 0;
    while (i < pos && cur->next != nullptr) {
        prev = cur;
        cur = cur->next;
        i++;
    }

    if(cur == l->head) {
        // 删除首元素
        *ret = cur->value;
        l->head = cur->next;
    } else if(cur == l->tail) {
        // 删除最后一个元素
        *ret = cur->value;
        l->tail = prev;
        prev->next = nullptr;
    } else {
        *ret = cur->value;
        prev->next = cur->next;
    }
    free(cur);
    l->size--;
    return true;
}
```

### 查找

由于链表结构的限制，只能进行 **顺序查找**。成功查找，返回索引；失败，返回 `-1

补充 `Find` 函数原型

```c title:list.h
int Find(elem_t e, list_t l);
```

补充 `Find` 函数实现

```c title:list.c
int Find(elem_t e, list_t l) {
    if (l == nullptr) {
        return -1;
    }
    node_t cur = l->head;
    int i = 0;
    while (cur != nullptr) {
        if (cur->value == e) {
           return i;
        }
        cur = cur->next;
        i++;
    }
    return -1;
}
```

## 双链表

在实现链表的 `Pop` 和 `Remove` 函数时，我们发现了一个问题：当我们需要删除最后一个结点时，需要从第一个结点开始遍历，查找到最后一个结点的前一个结点。这个问题导致我们在链表尾部删除元素时的时间复杂度变为 $O(n)$。为了解决该问题，我们让每个结点多存储一个**指针**，这个指针 **指向了该结点的上一个结点**

![[Pasted image 20241001103742.png]]




