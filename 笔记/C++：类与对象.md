# 类与对象

## 面向对象编程思想

在过程模式中，我们把程序看成是操纵 **被动对象** 的 **主动主体**

> [!tip] 被动对象
> 
> **数据** 和 **数据项** 构成类程序世界中的被动对象
> 

> [!tip] 主动主体
> 
> 程序本身就是发起动作的主动主体
> 

在面向过程模式下，被动对象的数据项存储在计算机内存中，程序使用 **过程** 操作被动对象

> [!tip] 过程
> 
> 所谓的过程就是程序发出的动作
> 

考虑一个文件打印的程序。在面向过程模式下，为了能打印，文件需要保持在内存中。因此，文件就是一个被动对象。程序使用一个称为 `print` 的过程，该过程告诉计算机如何打印文件中的每个字节

> [!tip] 
> 
> 程序使用过程的行为称为 **调用**
> 

在面向过程模式下，**对象和过程是完全分开的实体**。对象是一个能接收过程的独立实体

![[Pasted image 20250123184217.png]]


与面向过程模式不同，面向对象模式处理 **活动对象**，而不被动对象。活动对象能执行的动作都包含在该对象中：对象只需要接收合适的外部刺激来执行其中一个动作

> [!tip] 活动对象
> 
> 能够执行的动作都包含在对象中，对象只要接收到合适的刺激就能执行其中的动作
> 

继续考虑文件打印程序。在面向对象模式中，文件能把所有的被文件执行的过程打包在一起。在这种模式中，程序仅仅像对象发送一个相应的请求即可

![[Pasted image 20250123184417.png]]

## 类基础

**C++ 中类是创建新类型的工具**，创建出的类型可以像内置类型一样方便的使用。**派生类** 和模板允许我们 **表达类之间的关系** 并利用这些关系

> [!tip] 类型表达了一种概念
> 
> C++ 的内置类型 `float` 和 运算符 `+, -, *, /` 一起提供了数学概念 **实数** 的近似表示
> 

类是用户自定义类型。如果一个概念没有直接对应的内置类型，我们可以定义一个新类型表示这个概念

> [!tip] 
> 
> 在程序中使用与概念匹配的类型，可以使程序更容易理解，更容易分析，也更容易被修改
> 

定义一个新类型的基本思路：将实现细节与正确使用它的必要属性分离

> [!tip] 
> 
> 换句话说就是，将类型 **对象的数据存储布局** 与 **访问数据的函数的完整列表** 分开
> 

下面是定义一个类的完整语法形式

```cpp
class  Name [: 继承方式 基类,...]
{
访问控制限定符:
	// 构造函数的定义
	Name(形参表): 成员变量{初值}, ... {}// 或者 Name(形参表); 仅仅是声明
	// 析构函数的声明
	~Name();

	// 成员函数的声明
	返回类型 函数名(形参表) [const] [异常说明];
	
	// 表现形式
	数据类型 变量名;
}
```

例如，一个类 `X` 的定义如下

```cpp
class X
{
private:  // 类的实现细节，是私有的
    int m; 
public:   // 用户接口是公有的
    X(int i = 0) : m{i} {}; // 构造函数，初始化数据成员 m

    int mf(int i)
    {
        int old = m;
        m = i; // 将数据成员 m 设置为新值
        return old; // 返回旧值
    }
};

X var{7}; // 一个 X 类型的变量，初始化为 7

int user(X var, X* ptr)
{
    int x = var.mf(7); // 使用 var.mf() 成员函数
    int y = ptr->mf(9); // 使用 ptr->mf() 成员函数
    int z = var.m; // 错误：不能访问私有成员
}
```


